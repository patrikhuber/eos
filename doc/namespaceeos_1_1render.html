<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>eos: eos::render Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eos
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="namespaceeos_1_1render.html">render</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eos::render Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>3D mesh and texture extraction functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a 3D mesh consisting of vertices, vertex colour information and texture coordinates.  <a href="structeos_1_1render_1_1_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a298bda0bf8e9ee6947522b96d32ab237"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> { <b>NearestNeighbour</b>, 
<b>Bilinear</b>, 
<b>Area</b>
 }<tr class="separator:a298bda0bf8e9ee6947522b96d32ab237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b4673997fae6d670d7a9cc23543e8d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a9b4673997fae6d670d7a9cc23543e8d7">write_obj</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, std::string filename)</td></tr>
<tr class="memdesc:a9b4673997fae6d670d7a9cc23543e8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given <a class="el" href="structeos_1_1render_1_1_mesh.html" title="This class represents a 3D mesh consisting of vertices, vertex colour information and texture coordin...">Mesh</a> to an obj file that for example can be read by Meshlab.  <a href="#a9b4673997fae6d670d7a9cc23543e8d7">More...</a><br /></td></tr>
<tr class="separator:a9b4673997fae6d670d7a9cc23543e8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6561b065b9c0dd6815580ab12c3204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#afd6561b065b9c0dd6815580ab12c3204">write_textured_obj</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, std::string filename)</td></tr>
<tr class="memdesc:afd6561b065b9c0dd6815580ab12c3204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an obj file of the given <a class="el" href="structeos_1_1render_1_1_mesh.html" title="This class represents a 3D mesh consisting of vertices, vertex colour information and texture coordin...">Mesh</a>, including texture coordinates, and an mtl file containing a reference to the isomap.  <a href="#afd6561b065b9c0dd6815580ab12c3204">More...</a><br /></td></tr>
<tr class="separator:afd6561b065b9c0dd6815580ab12c3204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7628a42875570658bea6ffb4f46723e5"><td class="memItemLeft" align="right" valign="top">std::pair&lt; cv::Mat, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a7628a42875570658bea6ffb4f46723e5">render</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, cv::Mat model_view_matrix, cv::Mat projection_matrix, int viewport_width, int viewport_height, const <a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a> &amp;texture, bool enable_backface_culling=false, bool enable_near_clipping=true, bool enable_far_clipping=true)</td></tr>
<tr class="separator:a7628a42875570658bea6ffb4f46723e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adc532475d45d16f7b0c0eddf1bc7cb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; cv::Mat, cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a1adc532475d45d16f7b0c0eddf1bc7cb">render_affine</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, cv::Mat affine_camera_matrix, int viewport_width, int viewport_height, bool do_backface_culling=true)</td></tr>
<tr class="separator:a1adc532475d45d16f7b0c0eddf1bc7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa8c960c3b6eb080da1536cc3634577"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aafa8c960c3b6eb080da1536cc3634577">extract_texture</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, cv::Mat affine_camera_matrix, cv::Mat image, cv::Mat depthbuffer, bool compute_view_angle, <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> mapping_type, int isomap_resolution)</td></tr>
<tr class="separator:aafa8c960c3b6eb080da1536cc3634577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad663c29566fafc33606349a35d0bdbf1"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#ad663c29566fafc33606349a35d0bdbf1">extract_texture</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, cv::Mat affine_camera_matrix, cv::Mat image, bool compute_view_angle=false, <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> mapping_type=TextureInterpolation::NearestNeighbour, int isomap_resolution=512)</td></tr>
<tr class="separator:ad663c29566fafc33606349a35d0bdbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb2f816e97ecb7f33cf8a50328e0db"><td class="memItemLeft" align="right" valign="top">cv::Vec2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a04bb2f816e97ecb7f33cf8a50328e0db">clip_to_screen_space</a> (const cv::Vec2f &amp;clip_coordinates, int screen_width, int screen_height)</td></tr>
<tr class="separator:a04bb2f816e97ecb7f33cf8a50328e0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4b923267e9b3b09c0c588bfdd4cb85"><td class="memItemLeft" align="right" valign="top">cv::Vec2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a7c4b923267e9b3b09c0c588bfdd4cb85">screen_to_clip_space</a> (const cv::Vec2f &amp;screen_coordinates, int screen_width, int screen_height)</td></tr>
<tr class="separator:a7c4b923267e9b3b09c0c588bfdd4cb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72cdee6eed13468a424824ddd0b3074"><td class="memItemLeft" align="right" valign="top">cv::Vec3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#ac72cdee6eed13468a424824ddd0b3074">calculate_face_normal</a> (const cv::Vec3f &amp;v0, const cv::Vec3f &amp;v1, const cv::Vec3f &amp;v2)</td></tr>
<tr class="separator:ac72cdee6eed13468a424824ddd0b3074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edecd42a4a04ba6eb95089dd3ff256a"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a4edecd42a4a04ba6eb95089dd3ff256a">draw_texcoords</a> (<a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a> mesh, cv::Mat image=cv::Mat())</td></tr>
<tr class="separator:a4edecd42a4a04ba6eb95089dd3ff256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bff3cd388659995ccf49920ac727f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53bff3cd388659995ccf49920ac727f7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>get_max_possible_mipmaps_num</b> (unsigned int width, unsigned int height)</td></tr>
<tr class="separator:a53bff3cd388659995ccf49920ac727f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206355ac99e122f0a612c0fffa95f5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8206355ac99e122f0a612c0fffa95f5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_power_of_two</b> (int x)</td></tr>
<tr class="separator:a8206355ac99e122f0a612c0fffa95f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d461e2a61bd7ab7d90734ec779250d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73d461e2a61bd7ab7d90734ec779250d"></a>
<a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_mipmapped_texture</b> (cv::Mat image, unsigned int mipmapsNum=0)</td></tr>
<tr class="separator:a73d461e2a61bd7ab7d90734ec779250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>3D mesh and texture extraction functionality. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a298bda0bf8e9ee6947522b96d32ab237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">eos::render::TextureInterpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The interpolation types that can be used to map the texture from the original image to the isomap. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac72cdee6eed13468a424824ddd0b3074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Vec3f eos::render::calculate_face_normal </td>
          <td>(</td>
          <td class="paramtype">const cv::Vec3f &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Vec3f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Vec3f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the normal of a face (or triangle), i.e. the per-face normal. Return normal will be normalised. Assumes the triangle is given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length normal of the given triangle. </dd></dl>

</div>
</div>
<a class="anchor" id="a04bb2f816e97ecb7f33cf8a50328e0db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Vec2f eos::render::clip_to_screen_space </td>
          <td>(</td>
          <td class="paramtype">const cv::Vec2f &amp;&#160;</td>
          <td class="paramname"><em>clip_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a point from clip space ([-1, 1] x [-1, 1]) to image (screen) coordinates, i.e. the window transform. Note that the y-coordinate is flipped because the image origin is top-left while in clip space top is +1 and bottom is -1. No z-division is performed. Note: It should rather be called from NDC to screen space?</p>
<p>Exactly conforming to the OpenGL viewport transform, except that we flip y at the end. Qt: Origin top-left. OpenGL: bottom-left. OCV: top-left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clip_coordinates</td><td>A point in clip coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to screen space. </dd></dl>

</div>
</div>
<a class="anchor" id="a4edecd42a4a04ba6eb95089dd3ff256a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::render::draw_texcoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture coordinates (uv-coords) of the given mesh into an image by looping over the triangles and drawing each triangle's texcoords.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An optional image to draw onto. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An image with the texture coordinate triangles drawn in it, 512x512 if no image is given. </dd></dl>

</div>
</div>
<a class="anchor" id="aafa8c960c3b6eb080da1536cc3634577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::render::extract_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>depthbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_view_angle</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a>&#160;</td>
          <td class="paramname"><em>mapping_type</em> = <code>TextureInterpolation::NearestNeighbour</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isomap_resolution</em> = <code>512</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the texture of the face from the given image and stores it as isomap (a rectangular texture map). This function can be used if a depth buffer has already been computed. To just run the texture extraction, see the overload extract_texture(Mesh, cv::Mat, cv::Mat, TextureInterpolation, int).</p>
<p>It might be wise to remove this overload as it can get quite confusing with the zbuffer. Obviously the depthbuffer given should have been created with the same (affine or ortho) projection matrix than the texture extraction is called with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>An estimated 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image to extract the texture from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthbuffer</td><td>A pre-calculated depthbuffer image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_view_angle</td><td>A flag whether the view angle of each vertex should be computed and returned. If set to true, the angle will be encoded into the alpha channel (0 meaning occluded or facing away 90°, 127 meaning facing a 45° angle and 255 meaning front-facing, and all values in between). If set to false, the alpha channel will only contain 0 for occluded vertices and 255 for visible vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_type</td><td>The interpolation type to be used for the extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isomap_resolution</td><td>The resolution of the generated isomap. Defaults to 512x512. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted texture as isomap (texture map). </dd></dl>

</div>
</div>
<a class="anchor" id="ad663c29566fafc33606349a35d0bdbf1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::render::extract_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_view_angle</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a>&#160;</td>
          <td class="paramname"><em>mapping_type</em> = <code>TextureInterpolation::NearestNeighbour</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isomap_resolution</em> = <code>512</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the texture of the face from the given image and stores it as isomap (a rectangular texture map).</p>
<p>Note/#Todo: Only use TextureInterpolation::NearestNeighbour for the moment, the other methods don't have correct handling of the alpha channel (and will most likely throw an exception).</p>
<p>Todo: These should be renamed to extract_texture_affine? Can we combine both cases somehow? Or an overload with RenderingParameters?</p>
<p>For TextureInterpolation::NearestNeighbour, returns a 4-channel isomap with the visibility in the 4th channel (0=invis, 255=visible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>An estimated 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image to extract the texture from. Should be 8UC3, other types not supported yet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_view_angle</td><td>A flag whether the view angle of each vertex should be computed and returned. If set to true, the angle will be encoded into the alpha channel (0 meaning occluded or facing away 90°, 127 meaning facing a 45° angle and 255 meaning front-facing, and all values in between). If set to false, the alpha channel will only contain 0 for occluded vertices and 255 for visible vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_type</td><td>The interpolation type to be used for the extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isomap_resolution</td><td>The resolution of the generated isomap. Defaults to 512x512. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted texture as isomap (texture map). </dd></dl>

</div>
</div>
<a class="anchor" id="a7628a42875570658bea6ffb4f46723e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;cv::Mat, cv::Mat&gt; eos::render::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>model_view_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backface_culling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_near_clipping</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_far_clipping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This file implements a software renderer conforming to OpenGL conventions. The following are implementation notes, mostly for reference, or as a reminder of what exactly is going on. Don't try to understand them :-)</p>
<p>The renderer was initially based on code by Wojciech Sterna (<a href="http://maxest.gct-game.net/content/vainmoinen/index.html">http://maxest.gct-game.net/content/vainmoinen/index.html</a>), however, it has since then been completely rewritten. Still I'd like to thank him for making his code available and bravely answering my questions via email.</p>
<p>Coordinate systems: When specifying the vertices: +x = right, +y = up, we look into -z. So z = 0.5 is in front of 0.0. Z-Buffer:</p>
<p>Shirley: Specify n and f with negative values. which makes sense b/c the points are along the -z axis. Consequences: notably: orthogonal(2, 3): Shirley has denominator (n-f). In what space are the points in Shirley after this? OGL: We're in the orthographic viewing volume looking down -z. However, n and f are specified positive.</p>
<p>B/c the 3D points in front of the cam obviously still have negative z values, the z-value is negated. So: n = 0.1, f = 100; With the given OpenGL ortho matrix, it means a point on the near-plane which will have z = -0.1 will land up on z_clip (which equals z_ndc with ortho because w=1) = -1, and a point on the far plane z = -100 will have z_ndc = +1.</p>
<p>That's also why in the perspective case, w_clip is set to -z_eye because to project a point the formula is $x_p = (-n * x_e)/z_e$ (because our near is specified with positive values, but the near-plane is <em>really</em> at -n); but now we just move the minus-sign to the denominator, $x_p = (n * x_e)/-z_e$, so in the projection matrix we can use the (positive) n and f values and afterwards we divide by w = -z_e.</p>
<p><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p>
<p>Random notes: clip-space: after applying the projection matrix. ndc: after division by w NDC cube: the range of x-coordinate from [l, r] to [-1, 1], the y-coordinate from [b, t] to [-1, 1] and the z-coordinate from [n, f] to [-1, 1].</p>
<p>Note/Todo: I read that in screen space, OpenGL transform the z-values again to be between 0 and 1?</p>
<p>In contrast to OGL, this renderer doesn't have state, it's just a function that gets called with all necessary parameters. It's easiest for our purposes.</p>
<p>Here's the whole rendering pipeline: Model space -&gt; model transforms World space -&gt; camera (view/eye) transform View / eye / camera space ("truncated pyramid frustum". In case of ortho, it's already rectangular.) -&gt; perspective/ortho projection Clip coords (x_c, y_c, z_c, w_c); the z-axis is flipped now. z [z=-n, z=-f] is mapped to [-1, +1] in case of ortho, but not yet in case of persp (it's also flipped though), but the not-[-1,1]-range is fine as we test against w_c. I.e. the larger the z-value, the further back we are. Do frustum culling (clipping) here. Test the clip-coords with w_c, and discard if a tri is completely outside. Of the partially visible tris, clip them against the near-plane and construct the visible part of the triangle. We only do this for the near-plane here. Clipping to the near plane must be done here because after w-division triangles crossing it would get distorted. "Then, OpenGL will reconstruct the edges of the polygon where clipping occurs." -&gt; Then divide by the w component of the clip coordinates NDC. (now only 3D vectors: [x_ndc, y_ndc, z_ndc]). nearest points have z=-1, points on far plane have z=+1. -&gt; window transform. (also, OGL does some more to the z-buffer?) Screen / window space Directly after window-transform (still processing triangles), do backface culling with areVerticesCCWInScreenSpace() Directly afterwards we calculate the triangle's bounding box and clip x/y (screen) against 0 and the viewport width/height. Rasterising: Clipping against the far plane here by only drawing those pixels with a z-value of &lt;= 1.0f.</p>
<p>OGL: "both clipping (frustum culling) and NDC transformations are integrated into GL_PROJECTION matrix"</p>
<p>Note: In both the ortho and persp case, points at z=-n end up at -1, z=-f at +1. In case of persp proj., this happens only after the divide by w. Renders the given mesh onto a 2D image using 4x4 model-view and projection matrices. Conforms to OpenGL conventions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_view_matrix</td><td>A 4x4 OpenGL model-view matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>A 4x4 orthographic or perspective OpenGL projection matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>An optional texture map (TODO: Not optional yet!). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backface_culling</td><td>Whether the renderer should perform backface culling. If true, only draw triangles with vertices ordered CCW in screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_near_clipping</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_far_clipping</td><td>Screen height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with the colourbuffer as its first element and the depthbuffer as the second element. </dd></dl>

</div>
</div>
<a class="anchor" id="a1adc532475d45d16f7b0c0eddf1bc7cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;cv::Mat, cv::Mat&gt; eos::render::render_affine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_backface_culling</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renders the mesh using the given affine camera matrix and returns the colour and depth buffer images. The camera matrix should be one estimated with <a class="el" href="namespaceeos_1_1fitting.html#afce5f7297094056a04ad26785c94bbd8">fitting::estimate_affine_camera</a> (Hartley &amp; Zisserman algorithm).</p>
<p>If the given mesh is a shape-only mesh without vertex-colour information, the vertices will be rendered in grey.</p>
<p>#Todo: May consider an overload where we pass in an image, use that as colourbuffer and draw over it. #Todo: Add texture rendering to this. Then, create an additional function in extract_texure that is fully optimised for only the extraction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_backface_culling</td><td>Whether the renderer should perform backface culling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with the colourbuffer as its first element and the depthbuffer as the second element. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c4b923267e9b3b09c0c588bfdd4cb85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Vec2f eos::render::screen_to_clip_space </td>
          <td>(</td>
          <td class="paramtype">const cv::Vec2f &amp;&#160;</td>
          <td class="paramname"><em>screen_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a point from image (screen) coordinates to clip space ([-1, 1] x [-1, 1]). Note that the y-coordinate is flipped because the image origin is top-left while in clip space top is +1 and bottom is -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_coordinates</td><td>A point in screen coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to clip space. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b4673997fae6d670d7a9cc23543e8d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::write_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given <a class="el" href="structeos_1_1render_1_1_mesh.html" title="This class represents a 3D mesh consisting of vertices, vertex colour information and texture coordin...">Mesh</a> to an obj file that for example can be read by Meshlab. </p>
<p>If the mesh contains vertex colour information, it will be written to the obj as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to save as obj. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Output filename. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd6561b065b9c0dd6815580ab12c3204"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::write_textured_obj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1render_1_1_mesh.html">Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an obj file of the given <a class="el" href="structeos_1_1render_1_1_mesh.html" title="This class represents a 3D mesh consisting of vertices, vertex colour information and texture coordin...">Mesh</a>, including texture coordinates, and an mtl file containing a reference to the isomap. </p>
<p>The obj will contain texture coordinates for the mesh, and the mtl file will link to a file named &lt;filename&gt;.isomap.png. Note that the texture (isomap) has to be saved separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to save as obj. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Output filename. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

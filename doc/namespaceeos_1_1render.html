<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eos: eos::render Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eos
   &#160;<span id="projectnumber">0.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="namespaceeos_1_1render.html">render</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eos::render Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Software rendering and texture extraction functionality.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_extraction_fragment_shader.html">ExtractionFragmentShader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_rasterizer.html">Rasterizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Todo.  <a href="classeos_1_1render_1_1_rasterizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1render_1_1_rect.html">Rect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple type representing a rectangle.  <a href="structeos_1_1render_1_1_rect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_software_renderer.html">SoftwareRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.  <a href="classeos_1_1render_1_1_software_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a texture for rendering.  <a href="classeos_1_1render_1_1_texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_texturing_fragment_shader.html">TexturingFragmentShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment shader that textures...  <a href="classeos_1_1render_1_1_texturing_fragment_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_vertex_coloring_fragment_shader.html">VertexColoringFragmentShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fragment shader that does vertex-colouring.  <a href="classeos_1_1render_1_1_vertex_coloring_fragment_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_vertex_shader.html">VertexShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple vertex shader that projects the vertex and returns the vertex in clip-space coordinates.  <a href="classeos_1_1render_1_1_vertex_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4cbbcb06d3ae3d62763f91973ade6949"><td class="memTemplParams" colspan="2">template&lt;typename T , glm::precision P = glm::defaultp&gt; </td></tr>
<tr class="memitem:a4cbbcb06d3ae3d62763f91973ade6949"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a4cbbcb06d3ae3d62763f91973ade6949">Triangle</a> = std::array&lt; detail::Vertex&lt; T, P &gt;, 3 &gt;</td></tr>
<tr class="memdesc:a4cbbcb06d3ae3d62763f91973ade6949"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.  <a href="#a4cbbcb06d3ae3d62763f91973ade6949">More...</a><br /></td></tr>
<tr class="separator:a4cbbcb06d3ae3d62763f91973ade6949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a298bda0bf8e9ee6947522b96d32ab237"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> { <b>NearestNeighbour</b>, 
<b>Bilinear</b>, 
<b>Area</b>
 }</td></tr>
<tr class="separator:a298bda0bf8e9ee6947522b96d32ab237"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ed722f40b99b914c632667d8a2170b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a0ed722f40b99b914c632667d8a2170b3">draw_wireframe</a> (cv::Mat image, const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, glm::mat4x4 modelview, glm::mat4x4 projection, glm::vec4 viewport, cv::Scalar color=cv::Scalar(0, 255, 0, 255))</td></tr>
<tr class="separator:a0ed722f40b99b914c632667d8a2170b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c87e64cfa5af1fd1e26b3495f28db98"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a3c87e64cfa5af1fd1e26b3495f28db98">draw_texcoords</a> (<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> mesh, cv::Mat image=cv::Mat())</td></tr>
<tr class="separator:a3c87e64cfa5af1fd1e26b3495f28db98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdbbe1d81cf4f48e958162493973276"><td class="memTemplParams" colspan="2">template&lt;typename T , glm::precision P = glm::defaultp&gt; </td></tr>
<tr class="memitem:a3fdbbe1d81cf4f48e958162493973276"><td class="memTemplItemLeft" align="right" valign="top">glm::tvec3&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a3fdbbe1d81cf4f48e958162493973276">compute_inverse_perspectively_correct_lambda</a> (const glm::tvec3&lt; T, P &gt; &amp;lambda_world, const T &amp;one_over_w0, const T &amp;one_over_w1, const T &amp;one_over_w2)</td></tr>
<tr class="memdesc:a3fdbbe1d81cf4f48e958162493973276"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.  <a href="#a3fdbbe1d81cf4f48e958162493973276">More...</a><br /></td></tr>
<tr class="separator:a3fdbbe1d81cf4f48e958162493973276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef58049de4619a413bc33630d05a127"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>, <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#abef58049de4619a413bc33630d05a127">render</a> (<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> mesh, glm::tmat4x4&lt; float &gt; model_view_matrix, glm::tmat4x4&lt; float &gt; projection_matrix, int viewport_width, int viewport_height, const cpp17::optional&lt; <a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a> &gt; &amp;texture=cpp17::nullopt, bool enable_backface_culling=false, bool enable_near_clipping=true, bool enable_far_clipping=true)</td></tr>
<tr class="separator:abef58049de4619a413bc33630d05a127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa58987af5ac9e133013e679e427172b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>, <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#afa58987af5ac9e133013e679e427172b">render_affine</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, int viewport_width, int viewport_height, bool do_backface_culling=true)</td></tr>
<tr class="separator:afa58987af5ac9e133013e679e427172b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dc74e9455da95c8ac603bf3e72e21f"><td class="memTemplParams" colspan="2">template&lt;typename T , glm::precision P = glm::defaultp&gt; </td></tr>
<tr class="memitem:a60dc74e9455da95c8ac603bf3e72e21f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; detail::Vertex&lt; T, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a60dc74e9455da95c8ac603bf3e72e21f">clip_polygon_to_plane_in_4d</a> (const std::vector&lt; detail::Vertex&lt; T, P &gt;&gt; &amp;vertices, const glm::tvec4&lt; T, P &gt; &amp;plane_normal)</td></tr>
<tr class="memdesc:a60dc74e9455da95c8ac603bf3e72e21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Todo.  <a href="#a60dc74e9455da95c8ac603bf3e72e21f">More...</a><br /></td></tr>
<tr class="separator:a60dc74e9455da95c8ac603bf3e72e21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bff3cd388659995ccf49920ac727f7"><td class="memItemLeft" align="right" valign="top"><a id="a53bff3cd388659995ccf49920ac727f7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>get_max_possible_mipmaps_num</b> (unsigned int width, unsigned int height)</td></tr>
<tr class="separator:a53bff3cd388659995ccf49920ac727f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206355ac99e122f0a612c0fffa95f5c"><td class="memItemLeft" align="right" valign="top"><a id="a8206355ac99e122f0a612c0fffa95f5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_power_of_two</b> (int x)</td></tr>
<tr class="separator:a8206355ac99e122f0a612c0fffa95f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d461e2a61bd7ab7d90734ec779250d"><td class="memItemLeft" align="right" valign="top"><a id="a73d461e2a61bd7ab7d90734ec779250d"></a>
<a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_mipmapped_texture</b> (cv::Mat image, unsigned int mipmapsNum=0)</td></tr>
<tr class="separator:a73d461e2a61bd7ab7d90734ec779250d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446dbb9ee64286742462256e884bd0d9"><td class="memItemLeft" align="right" valign="top"><a id="a446dbb9ee64286742462256e884bd0d9"></a>
Eigen::Matrix&lt; float, 2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_affine_transform</b> (const std::array&lt; Eigen::Vector2f, 3 &gt; &amp;src, const std::array&lt; Eigen::Vector2f, 3 &gt; &amp;dst)</td></tr>
<tr class="separator:a446dbb9ee64286742462256e884bd0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe6cc3a347b8a0df2cac0f5c21c1f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#adfe6cc3a347b8a0df2cac0f5c21c1f72">extract_texture</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;image, const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a> &amp;depthbuffer, bool compute_view_angle, <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> mapping_type, int isomap_resolution)</td></tr>
<tr class="separator:adfe6cc3a347b8a0df2cac0f5c21c1f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f2beacfa4249f16431672483ea5215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a33f2beacfa4249f16431672483ea5215">extract_texture</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;image, bool compute_view_angle=false, <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a> mapping_type=TextureInterpolation::NearestNeighbour, int isomap_resolution=512)</td></tr>
<tr class="separator:a33f2beacfa4249f16431672483ea5215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebeb832d9911b6fef9d9ee9e9ca6bdc"><td class="memItemLeft" align="right" valign="top">glm::vec2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aeebeb832d9911b6fef9d9ee9e9ca6bdc">clip_to_screen_space</a> (const glm::vec2 &amp;clip_coordinates, int screen_width, int screen_height)</td></tr>
<tr class="separator:aeebeb832d9911b6fef9d9ee9e9ca6bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b27d0277e495c37fb34be1add7cd7d"><td class="memTemplParams" colspan="2">template&lt;typename T , glm::precision P = glm::defaultp&gt; </td></tr>
<tr class="memitem:a39b27d0277e495c37fb34be1add7cd7d"><td class="memTemplItemLeft" align="right" valign="top">glm::tvec2&lt; T, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a39b27d0277e495c37fb34be1add7cd7d">clip_to_screen_space</a> (const T clip_coord_x, const T clip_coord_y, int screen_width, int screen_height)</td></tr>
<tr class="separator:a39b27d0277e495c37fb34be1add7cd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9fd3f70cca4fdac35d2a01df36488c"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a6c9fd3f70cca4fdac35d2a01df36488c">compute_face_normal</a> (const Eigen::Vector3f &amp;v0, const Eigen::Vector3f &amp;v1, const Eigen::Vector3f &amp;v2)</td></tr>
<tr class="separator:a6c9fd3f70cca4fdac35d2a01df36488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182473d4bf5ed064098f7733b28001e3"><td class="memItemLeft" align="right" valign="top"><a id="a182473d4bf5ed064098f7733b28001e3"></a>
Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><b>compute_face_normal</b> (const Eigen::Vector4f &amp;v0, const Eigen::Vector4f &amp;v1, const Eigen::Vector4f &amp;v2)</td></tr>
<tr class="separator:a182473d4bf5ed064098f7733b28001e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152bc39ef2b37236c20db055bb78a12e"><td class="memItemLeft" align="right" valign="top">glm::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a152bc39ef2b37236c20db055bb78a12e">compute_face_normal</a> (const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, const glm::vec3 &amp;v2)</td></tr>
<tr class="separator:a152bc39ef2b37236c20db055bb78a12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Software rendering and texture extraction functionality. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a4cbbcb06d3ae3d62763f91973ade6949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbbcb06d3ae3d62763f91973ade6949">&#9670;&nbsp;</a></span>Triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , glm::precision P = glm::defaultp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeos_1_1render.html#a4cbbcb06d3ae3d62763f91973ade6949">eos::render::Triangle</a> = typedef std::array&lt;detail::Vertex&lt;T, P&gt;, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X. </p>
<p>Can this go into the <a class="el" href="classeos_1_1render_1_1_software_renderer.html" title="X. ">SoftwareRenderer</a> class or something? No, I think FragShader needs it? Where to put it? </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a298bda0bf8e9ee6947522b96d32ab237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298bda0bf8e9ee6947522b96d32ab237">&#9670;&nbsp;</a></span>TextureInterpolation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">eos::render::TextureInterpolation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The interpolation types that can be used to map the texture from the original image to the isomap. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a60dc74e9455da95c8ac603bf3e72e21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dc74e9455da95c8ac603bf3e72e21f">&#9670;&nbsp;</a></span>clip_polygon_to_plane_in_4d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , glm::precision P = glm::defaultp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; detail::Vertex&lt; T, P &gt; &gt; eos::render::clip_polygon_to_plane_in_4d </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; detail::Vertex&lt; T, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::tvec4&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>plane_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Todo. </p>
<p>This function copied from render_detail.hpp and adjusted for v2:: stuff. I think it should go back to render_details eventually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>X. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plane_normal</td><td>X. @ return X. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeebeb832d9911b6fef9d9ee9e9ca6bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebeb832d9911b6fef9d9ee9e9ca6bdc">&#9670;&nbsp;</a></span>clip_to_screen_space() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec2 eos::render::clip_to_screen_space </td>
          <td>(</td>
          <td class="paramtype">const glm::vec2 &amp;&#160;</td>
          <td class="paramname"><em>clip_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a point from clip space ([-1, 1] x [-1, 1]) to image (screen) coordinates, i.e. the window transform. Note that the y-coordinate is flipped because the image origin is top-left while in clip space top is +1 and bottom is -1. No z-division is performed. Note: It should rather be called from NDC to screen space?</p>
<p>Exactly conforming to the OpenGL viewport transform, except that we flip y at the end. Qt: Origin top-left. OpenGL: bottom-left. OCV: top-left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clip_coordinates</td><td>A point in clip coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to screen space. </dd></dl>

</div>
</div>
<a id="a39b27d0277e495c37fb34be1add7cd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b27d0277e495c37fb34be1add7cd7d">&#9670;&nbsp;</a></span>clip_to_screen_space() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , glm::precision P = glm::defaultp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">glm::tvec2&lt;T, P&gt; eos::render::clip_to_screen_space </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>clip_coord_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>clip_coord_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms a point from image (screen) coordinates to clip space ([-1, 1] x [-1, 1]). Note that the y-coordinate is flipped because the image origin is top-left while in clip space top is +1 and bottom is -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_coordinates</td><td>A point in screen coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to clip space. </dd></dl>

</div>
</div>
<a id="a6c9fd3f70cca4fdac35d2a01df36488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9fd3f70cca4fdac35d2a01df36488c">&#9670;&nbsp;</a></span>compute_face_normal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f eos::render::compute_face_normal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normal of a face (or triangle), i.e. the per-face normal. Return normal will be normalised. Assumes the triangle is given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length normal of the given triangle. </dd></dl>

</div>
</div>
<a id="a152bc39ef2b37236c20db055bb78a12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152bc39ef2b37236c20db055bb78a12e">&#9670;&nbsp;</a></span>compute_face_normal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec3 eos::render::compute_face_normal </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the normal of a face (or triangle), i.e. the per-face normal. Return normal will be normalised. Assumes the triangle is given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length normal of the given triangle. </dd></dl>

</div>
</div>
<a id="a3fdbbe1d81cf4f48e958162493973276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdbbe1d81cf4f48e958162493973276">&#9670;&nbsp;</a></span>compute_inverse_perspectively_correct_lambda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , glm::precision P = glm::defaultp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">glm::tvec3&lt;T, P&gt; eos::render::compute_inverse_perspectively_correct_lambda </td>
          <td>(</td>
          <td class="paramtype">const glm::tvec3&lt; T, P &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X. </p>
<p>X. Inverts the perspective texture mapping. Can be derived using some tedious algebra. Todo: Probably move to a texturing file, internal/detail one, where we will also put the tex2d, mipmapping etc stuff?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X. </dd></dl>

</div>
</div>
<a id="a3c87e64cfa5af1fd1e26b3495f28db98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c87e64cfa5af1fd1e26b3495f28db98">&#9670;&nbsp;</a></span>draw_texcoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::render::draw_texcoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture coordinates (uv-coords) of the given mesh into an image by looping over the triangles and drawing each triangle's texcoords.</p>
<p>Note/Todo: This function has a slight problems, the lines do not actually get drawn blue, if the image is 8UC4. Well if I save a PNG, it is blue. Not sure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An optional image to draw onto. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An image with the texture coordinate triangles drawn in it, 512x512 if no image is given. </dd></dl>

</div>
</div>
<a id="a0ed722f40b99b914c632667d8a2170b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed722f40b99b914c632667d8a2170b3">&#9670;&nbsp;</a></span>draw_wireframe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::draw_wireframe </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4x4&#160;</td>
          <td class="paramname"><em>modelview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4x4&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Scalar&#160;</td>
          <td class="paramname"><em>color</em> = <code>cv::Scalar(0,&#160;255,&#160;0,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the given mesh as wireframe into the image.</p>
<p>It does backface culling, i.e. draws only vertices in CCW order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An image to draw into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelview</td><td>Model-view matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>Projection matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Viewport to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>Colour of the mesh to be drawn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfe6cc3a347b8a0df2cac0f5c21c1f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe6cc3a347b8a0df2cac0f5c21c1f72">&#9670;&nbsp;</a></span>extract_texture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a> eos::render::extract_texture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a> &amp;&#160;</td>
          <td class="paramname"><em>depthbuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_view_angle</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a>&#160;</td>
          <td class="paramname"><em>mapping_type</em> = <code>TextureInterpolation::NearestNeighbour</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isomap_resolution</em> = <code>512</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the texture of the face from the given image and stores it as isomap (a rectangular texture map). This function can be used if a depth buffer has already been computed. To just run the texture extraction, see the overload extract_texture(Mesh, cv::Mat, cv::Mat, TextureInterpolation, int). // Todo: I think this signature needs updating.</p>
<p>It might be wise to remove this overload as it can get quite confusing with the zbuffer. Obviously the depthbuffer given should have been created with the same (affine or ortho) projection matrix than the texture extraction is called with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>An estimated 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image to extract the texture from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthbuffer</td><td>A pre-calculated depthbuffer image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_view_angle</td><td>A flag whether the view angle of each vertex should be computed and returned. If set to true, the angle will be encoded into the alpha channel (0 meaning occluded or facing away 90°, 127 meaning facing a 45° angle and 255 meaning front-facing, and all values in between). If set to false, the alpha channel will only contain 0 for occluded vertices and 255 for visible vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_type</td><td>The interpolation type to be used for the extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isomap_resolution</td><td>The resolution of the generated isomap. Defaults to 512x512. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted texture as isomap (texture map). </dd></dl>

</div>
</div>
<a id="a33f2beacfa4249f16431672483ea5215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f2beacfa4249f16431672483ea5215">&#9670;&nbsp;</a></span>extract_texture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a> eos::render::extract_texture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compute_view_angle</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeos_1_1render.html#a298bda0bf8e9ee6947522b96d32ab237">TextureInterpolation</a>&#160;</td>
          <td class="paramname"><em>mapping_type</em> = <code>TextureInterpolation::NearestNeighbour</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isomap_resolution</em> = <code>512</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the texture of the face from the given image and stores it as isomap (a rectangular texture map).</p>
<p>Note/Todo: Only use TextureInterpolation::NearestNeighbour for the moment, the other methods don't have correct handling of the alpha channel (and will most likely throw an exception).</p>
<p>Todo: These should be renamed to extract_texture_affine? Can we combine both cases somehow? Or an overload with RenderingParameters?</p>
<p>For TextureInterpolation::NearestNeighbour, returns a 4-channel isomap with the visibility in the 4th channel (0=invis, 255=visible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>An estimated 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image to extract the texture from. Should be 8UC3, other types not supported yet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_view_angle</td><td>A flag whether the view angle of each vertex should be computed and returned. If set to true, the angle will be encoded into the alpha channel (0 meaning occluded or facing away 90°, 127 meaning facing a 45° angle and 255 meaning front-facing, and all values in between). If set to false, the alpha channel will only contain 0 for occluded vertices and 255 for visible vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_type</td><td>The interpolation type to be used for the extraction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isomap_resolution</td><td>The resolution of the generated isomap. Defaults to 512x512. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted texture as isomap (texture map). </dd></dl>

</div>
</div>
<a id="abef58049de4619a413bc33630d05a127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef58049de4619a413bc33630d05a127">&#9670;&nbsp;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>, <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a>&gt; eos::render::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::tmat4x4&lt; float &gt;&#160;</td>
          <td class="paramname"><em>model_view_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::tmat4x4&lt; float &gt;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpp17::optional&lt; <a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em> = <code>cpp17::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backface_culling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_near_clipping</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_far_clipping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This file implements a software renderer conforming to OpenGL conventions. The following are implementation notes, mostly for reference, or as a reminder of what exactly is going on. Don't try to understand them :-)</p>
<p>The renderer was initially based on code by Wojciech Sterna (<a href="http://maxest.gct-game.net/content/vainmoinen/index.html">http://maxest.gct-game.net/content/vainmoinen/index.html</a>), however, it has since then been completely rewritten. Still I'd like to thank him for making his code available and bravely answering my questions via email.</p>
<p>Coordinate systems: When specifying the vertices: +x = right, +y = up, we look into -z. So z = 0.5 is in front of 0.0. Z-Buffer:</p>
<p>Shirley: Specify n and f with negative values. which makes sense b/c the points are along the -z axis. Consequences: notably: orthogonal(2, 3): Shirley has denominator (n-f). In what space are the points in Shirley after this? OGL: We're in the orthographic viewing volume looking down -z. However, n and f are specified positive.</p>
<p>B/c the 3D points in front of the cam obviously still have negative z values, the z-value is negated. So: n = 0.1, f = 100; With the given OpenGL ortho matrix, it means a point on the near-plane which will have z = -0.1 will land up on z_clip (which equals z_ndc with ortho because w=1) = -1, and a point on the far plane z = -100 will have z_ndc = +1.</p>
<p>That's also why in the perspective case, w_clip is set to -z_eye because to project a point the formula is $x_p = (-n * x_e)/z_e$ (because our near is specified with positive values, but the near-plane is <em>really</em> at -n); but now we just move the minus-sign to the denominator, $x_p = (n * x_e)/-z_e$, so in the projection matrix we can use the (positive) n and f values and afterwards we divide by w = -z_e.</p>
<p><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></p>
<p>Random notes: clip-space: after applying the projection matrix. ndc: after division by w NDC cube: the range of x-coordinate from [l, r] to [-1, 1], the y-coordinate from [b, t] to [-1, 1] and the z-coordinate from [n, f] to [-1, 1].</p>
<p>Note/Todo: I read that in screen space, OpenGL transform the z-values again to be between 0 and 1?</p>
<p>In contrast to OGL, this renderer doesn't have state, it's just a function that gets called with all necessary parameters. It's easiest for our purposes.</p>
<p>Here's the whole rendering pipeline: Model space -&gt; model transforms World space -&gt; camera (view/eye) transform View / eye / camera space ("truncated pyramid frustum". In case of ortho, it's already rectangular.) -&gt; perspective/ortho projection Clip coords (x_c, y_c, z_c, w_c); the z-axis is flipped now. z [z=-n, z=-f] is mapped to [-1, +1] in case of ortho, but not yet in case of persp (it's also flipped though), but the not-[-1,1]-range is fine as we test against w_c. I.e. the larger the z-value, the further back we are. Do frustum culling (clipping) here. Test the clip-coords with w_c, and discard if a tri is completely outside. Of the partially visible tris, clip them against the near-plane and construct the visible part of the triangle. We only do this for the near-plane here. Clipping to the near plane must be done here because after w-division triangles crossing it would get distorted. "Then, OpenGL will reconstruct the edges of the polygon where clipping occurs." -&gt; Then divide by the w component of the clip coordinates NDC. (now only 3D vectors: [x_ndc, y_ndc, z_ndc]). nearest points have z=-1, points on far plane have z=+1. -&gt; window transform. (also, OGL does some more to the z-buffer?) Screen / window space Directly after window-transform (still processing triangles), do backface culling with areVerticesCCWInScreenSpace() Directly afterwards we calculate the triangle's bounding box and clip x/y (screen) against 0 and the viewport width/height. Rasterising: Clipping against the far plane here by only drawing those pixels with a z-value of &lt;= 1.0f.</p>
<p>OGL: "both clipping (frustum culling) and NDC transformations are integrated into GL_PROJECTION matrix"</p>
<p>Note: In both the ortho and persp case, points at z=-n end up at -1, z=-f at +1. In case of persp proj., this happens only after the divide by w. Renders the given mesh onto a 2D image using 4x4 model-view and projection matrices. Conforms to OpenGL conventions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_view_matrix</td><td>A 4x4 OpenGL model-view matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>A 4x4 orthographic or perspective OpenGL projection matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>An optional texture map. If not given, vertex-colouring is used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backface_culling</td><td>Whether the renderer should perform backface culling. If true, only draw triangles with vertices ordered CCW in screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_near_clipping</td><td>Whether vertices should be clipped against the near plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_far_clipping</td><td>Whether vertices should be clipped against the far plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with the colourbuffer as its first element and the depthbuffer as the second element. </dd></dl>

</div>
</div>
<a id="afa58987af5ac9e133013e679e427172b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa58987af5ac9e133013e679e427172b">&#9670;&nbsp;</a></span>render_affine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>, <a class="el" href="classeos_1_1core_1_1_image.html">core::Image1d</a>&gt; eos::render::render_affine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_backface_culling</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Renders the mesh using the given affine camera matrix and returns the colour and depth buffer images. The camera matrix should be one estimated with <a class="el" href="namespaceeos_1_1fitting.html#afce5f7297094056a04ad26785c94bbd8">fitting::estimate_affine_camera</a> (Hartley &amp; Zisserman algorithm).</p>
<p>If the given mesh is a shape-only mesh without vertex-colour information, the vertices will be rendered in grey.</p>
<p>#Todo: May consider an overload where we pass in an image, use that as colourbuffer and draw over it. #Todo: Add texture rendering to this. Then, create an additional function in extract_texure that is fully optimised for only the extraction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">do_backface_culling</td><td>Whether the renderer should perform backface culling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with the colourbuffer as its first element and the depthbuffer as the second element. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

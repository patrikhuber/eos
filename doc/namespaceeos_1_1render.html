<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eos: eos::render Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">eos<span id="projectnumber">&#160;1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="namespaceeos_1_1render.html">render</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">eos::render Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Software rendering and texture extraction functionality.  
<a href="namespaceeos_1_1render.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_extraction_fragment_shader.html">ExtractionFragmentShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment shader that is used to extract, or remap, texture from an image to a UV map (i.e. the reverse process of texturing).  <a href="classeos_1_1render_1_1_extraction_fragment_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_rasterizer.html">Rasterizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Todo.  <a href="classeos_1_1render_1_1_rasterizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_software_renderer.html">SoftwareRenderer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.  <a href="classeos_1_1render_1_1_software_renderer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a texture for rendering.  <a href="classeos_1_1render_1_1_texture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_texturing_fragment_shader.html">TexturingFragmentShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fragment shader that textures.  <a href="classeos_1_1render_1_1_texturing_fragment_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_vertex_coloring_fragment_shader.html">VertexColoringFragmentShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fragment shader that does vertex-colouring.  <a href="classeos_1_1render_1_1_vertex_coloring_fragment_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1render_1_1_vertex_shader.html">VertexShader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple vertex shader that projects the vertex and returns the vertex in clip-space coordinates.  <a href="classeos_1_1render_1_1_vertex_shader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a91f4a9efc6a3062e29a266782c116cf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91f4a9efc6a3062e29a266782c116cf0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a91f4a9efc6a3062e29a266782c116cf0">Triangle</a> = std::array&lt; detail::Vertex&lt; T &gt;, 3 &gt;</td></tr>
<tr class="memdesc:a91f4a9efc6a3062e29a266782c116cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">X.  <br /></td></tr>
<tr class="separator:a91f4a9efc6a3062e29a266782c116cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7b89db196c55aa0b6365200b2b1ddd13"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a7b89db196c55aa0b6365200b2b1ddd13">ProjectionType</a> { <b>Orthographic</b>
, <b>Perspective</b>
 }</td></tr>
<tr class="separator:a7b89db196c55aa0b6365200b2b1ddd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a51aa9b1aa73d0bcb2ee8f911fc4f4d40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a51aa9b1aa73d0bcb2ee8f911fc4f4d40">draw_line</a> (<a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;image, float x0, float y0, float x1, float y1, Eigen::Vector3f color)</td></tr>
<tr class="separator:a51aa9b1aa73d0bcb2ee8f911fc4f4d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d05494249ceda229d3cacbad5d4363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aa5d05494249ceda229d3cacbad5d4363">draw_wireframe</a> (<a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;image, const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix4f modelview, Eigen::Matrix4f projection, Eigen::Vector4f viewport, Eigen::Vector3f color=Eigen::Vector3f(0, 255, 0))</td></tr>
<tr class="separator:aa5d05494249ceda229d3cacbad5d4363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd18efdff1bf1a2d4713778ef4ba4cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafd18efdff1bf1a2d4713778ef4ba4cb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aafd18efdff1bf1a2d4713778ef4ba4cb">compute_inverse_perspectively_correct_lambda</a> (const Eigen::Vector3&lt; T &gt; &amp;lambda_world, const T &amp;one_over_w0, const T &amp;one_over_w1, const T &amp;one_over_w2)</td></tr>
<tr class="memdesc:aafd18efdff1bf1a2d4713778ef4ba4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inverse perspectively correct lambda.  <br /></td></tr>
<tr class="separator:aafd18efdff1bf1a2d4713778ef4ba4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b47fe0990755fdd540b97cc77a8a1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55b47fe0990755fdd540b97cc77a8a1b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix4&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a55b47fe0990755fdd540b97cc77a8a1b">perspective</a> (T fov_y, T aspect, T z_near, T z_far)</td></tr>
<tr class="separator:a55b47fe0990755fdd540b97cc77a8a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148b6d7384a192326576430c64e10595"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a148b6d7384a192326576430c64e10595"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix4&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a148b6d7384a192326576430c64e10595">ortho</a> (T left, T right, T bottom, T top)</td></tr>
<tr class="memdesc:a148b6d7384a192326576430c64e10595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2D orthographic projection matrix.  <br /></td></tr>
<tr class="separator:a148b6d7384a192326576430c64e10595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a22b899d57fd3e472910241f5592487"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a22b899d57fd3e472910241f5592487"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix4&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a2a22b899d57fd3e472910241f5592487">ortho</a> (T left, T right, T bottom, T top, T z_near, T z_far)</td></tr>
<tr class="memdesc:a2a22b899d57fd3e472910241f5592487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates.  <br /></td></tr>
<tr class="separator:a2a22b899d57fd3e472910241f5592487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91f10062952969ca3fba1d94c8f77692"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91f10062952969ca3fba1d94c8f77692"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a91f10062952969ca3fba1d94c8f77692">project</a> (const Eigen::Vector3&lt; T &gt; &amp;point_3d, const Eigen::Matrix4&lt; T &gt; &amp;modelview_matrix, const Eigen::Matrix4&lt; T &gt; &amp;projection_matrix, const Eigen::Vector4&lt; T &gt; &amp;viewport)</td></tr>
<tr class="separator:a91f10062952969ca3fba1d94c8f77692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9fd3f70cca4fdac35d2a01df36488c"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a6c9fd3f70cca4fdac35d2a01df36488c">compute_face_normal</a> (const Eigen::Vector3f &amp;v0, const Eigen::Vector3f &amp;v1, const Eigen::Vector3f &amp;v2)</td></tr>
<tr class="separator:a6c9fd3f70cca4fdac35d2a01df36488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182473d4bf5ed064098f7733b28001e3"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a182473d4bf5ed064098f7733b28001e3">compute_face_normal</a> (const Eigen::Vector4f &amp;v0, const Eigen::Vector4f &amp;v1, const Eigen::Vector4f &amp;v2)</td></tr>
<tr class="separator:a182473d4bf5ed064098f7733b28001e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ab153b18b90c00a82b5e30afd52f1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a52ab153b18b90c00a82b5e30afd52f1d">compute_face_normals</a> (const std::vector&lt; Eigen::Vector3f &gt; &amp;vertices, const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;triangle_vertex_indices)</td></tr>
<tr class="separator:a52ab153b18b90c00a82b5e30afd52f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a065cfacba7489d406d66fcaa2f231"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Eigen::Vector3f &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aa8a065cfacba7489d406d66fcaa2f231">compute_vertex_normals</a> (const std::vector&lt; Eigen::Vector3f &gt; &amp;vertices, const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;triangle_vertex_indices, const std::vector&lt; Eigen::Vector3f &gt; &amp;face_normals)</td></tr>
<tr class="separator:aa8a065cfacba7489d406d66fcaa2f231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b2dc90d646185cf9e09b2b21c91f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a13b2dc90d646185cf9e09b2b21c91f9e">draw_wireframe</a> (cv::Mat image, const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix4f modelview, Eigen::Matrix4f projection, Eigen::Vector4f viewport, cv::Scalar color=cv::Scalar(0, 255, 0, 255))</td></tr>
<tr class="separator:a13b2dc90d646185cf9e09b2b21c91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c87e64cfa5af1fd1e26b3495f28db98"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a3c87e64cfa5af1fd1e26b3495f28db98">draw_texcoords</a> (<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> mesh, cv::Mat image=cv::Mat())</td></tr>
<tr class="separator:a3c87e64cfa5af1fd1e26b3495f28db98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a18dc1026bffbba577dfe4b3198d12"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, cpp17::optional&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a26a18dc1026bffbba577dfe4b3198d12">ray_triangle_intersect</a> (const Eigen::Vector3f &amp;ray_origin, const Eigen::Vector3f &amp;ray_direction, const Eigen::Vector3f &amp;v0, const Eigen::Vector3f &amp;v1, const Eigen::Vector3f &amp;v2, bool enable_backculling)</td></tr>
<tr class="memdesc:a26a18dc1026bffbba577dfe4b3198d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of the given ray with the given triangle.  <br /></td></tr>
<tr class="separator:a26a18dc1026bffbba577dfe4b3198d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c27ad77dc83d41ee3f885bf8434d69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#ae7c27ad77dc83d41ee3f885bf8434d69">render</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const Eigen::Matrix4f &amp;model_view_matrix, const Eigen::Matrix4f &amp;projection_matrix, int viewport_width, int viewport_height, bool enable_backface_culling=false, bool enable_near_clipping=true, bool enable_far_clipping=true)</td></tr>
<tr class="separator:ae7c27ad77dc83d41ee3f885bf8434d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad344b915901f03cd523c9c6a3496a01a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#ad344b915901f03cd523c9c6a3496a01a">render</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const Eigen::Matrix4f &amp;model_view_matrix, const Eigen::Matrix4f &amp;projection_matrix, int viewport_width, int viewport_height, <a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a> texture, bool enable_backface_culling=false, bool enable_near_clipping=true, bool enable_far_clipping=true)</td></tr>
<tr class="separator:ad344b915901f03cd523c9c6a3496a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bff3cd388659995ccf49920ac727f7"><td class="memItemLeft" align="right" valign="top"><a id="a53bff3cd388659995ccf49920ac727f7" name="a53bff3cd388659995ccf49920ac727f7"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>get_max_possible_mipmaps_num</b> (unsigned int width, unsigned int height)</td></tr>
<tr class="separator:a53bff3cd388659995ccf49920ac727f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206355ac99e122f0a612c0fffa95f5c"><td class="memItemLeft" align="right" valign="top"><a id="a8206355ac99e122f0a612c0fffa95f5c" name="a8206355ac99e122f0a612c0fffa95f5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_power_of_two</b> (int x)</td></tr>
<tr class="separator:a8206355ac99e122f0a612c0fffa95f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e548a36b692e9c1e5589791c2e5e549"><td class="memItemLeft" align="right" valign="top"><a id="a3e548a36b692e9c1e5589791c2e5e549" name="a3e548a36b692e9c1e5589791c2e5e549"></a>
<a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_mipmapped_texture</b> (const <a class="el" href="classeos_1_1core_1_1_image.html">eos::core::Image4u</a> &amp;image, unsigned int mipmapsNum=0)</td></tr>
<tr class="separator:a3e548a36b692e9c1e5589791c2e5e549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d12e5339e0b016ead391ebc9cc79e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1core_1_1_image.html">eos::core::Image4u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a01d12e5339e0b016ead391ebc9cc79e6">extract_texture</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, Eigen::Matrix4f view_model_matrix, Eigen::Matrix4f projection_matrix, <a class="el" href="namespaceeos_1_1render.html#a7b89db196c55aa0b6365200b2b1ddd13">ProjectionType</a> projection_type, const <a class="el" href="classeos_1_1core_1_1_image.html">eos::core::Image4u</a> &amp;image, int texturemap_resolution=512)</td></tr>
<tr class="memdesc:a01d12e5339e0b016ead391ebc9cc79e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the texture from the given image and returns a texture map.  <br /></td></tr>
<tr class="separator:a01d12e5339e0b016ead391ebc9cc79e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548120a160202248e0cde10f05e01f1b"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a548120a160202248e0cde10f05e01f1b">clip_to_screen_space</a> (const Eigen::Vector2f &amp;clip_coordinates, int screen_width, int screen_height)</td></tr>
<tr class="separator:a548120a160202248e0cde10f05e01f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2199d8bdb329e3d29c9c8d8de80f58f"><td class="memTemplParams" colspan="2"><a id="aa2199d8bdb329e3d29c9c8d8de80f58f" name="aa2199d8bdb329e3d29c9c8d8de80f58f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2199d8bdb329e3d29c9c8d8de80f58f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clip_to_screen_space</b> (const T clip_coord_x, const T clip_coord_y, int screen_width, int screen_height)</td></tr>
<tr class="separator:aa2199d8bdb329e3d29c9c8d8de80f58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6937bd32bc52fcc61b40fa1587fb9307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a6937bd32bc52fcc61b40fa1587fb9307">is_vertex_visible</a> (const Eigen::Vector3f &amp;probe_vertex, const std::vector&lt; Eigen::Vector3f &gt; &amp;mesh_vertices, const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;mesh_triangle_vertex_indices, detail::RayDirection ray_direction_type)</td></tr>
<tr class="separator:a6937bd32bc52fcc61b40fa1587fb9307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da7d2bf93f962114a774fefa0ecfd7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#a73da7d2bf93f962114a774fefa0ecfd7">compute_per_vertex_self_occlusion</a> (const std::vector&lt; Eigen::Vector3f &gt; &amp;viewspace_vertices, const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;triangle_vertex_indices, detail::RayDirection ray_direction_type)</td></tr>
<tr class="separator:a73da7d2bf93f962114a774fefa0ecfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac72e19ce0b13a1d97d5824cfc848796"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1render.html#aac72e19ce0b13a1d97d5824cfc848796">compute_per_vertex_self_occlusion</a> (const std::vector&lt; Eigen::Vector3f &gt; &amp;vertices, const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;triangle_vertex_indices, const Eigen::Matrix4f &amp;modelview, detail::RayDirection ray_direction_type)</td></tr>
<tr class="separator:aac72e19ce0b13a1d97d5824cfc848796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Software rendering and texture extraction functionality. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a91f4a9efc6a3062e29a266782c116cf0" name="a91f4a9efc6a3062e29a266782c116cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f4a9efc6a3062e29a266782c116cf0">&#9670;&#160;</a></span>Triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceeos_1_1render.html#a91f4a9efc6a3062e29a266782c116cf0">eos::render::Triangle</a> = typedef std::array&lt;detail::Vertex&lt;T&gt;, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>X. </p>
<p>Can this go into the <a class="el" href="classeos_1_1render_1_1_software_renderer.html" title="X.">SoftwareRenderer</a> class or something? No, I think FragShader needs it? Where to put it? </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7b89db196c55aa0b6365200b2b1ddd13" name="a7b89db196c55aa0b6365200b2b1ddd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b89db196c55aa0b6365200b2b1ddd13">&#9670;&#160;</a></span>ProjectionType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceeos_1_1render.html#a7b89db196c55aa0b6365200b2b1ddd13">eos::render::ProjectionType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether orthographic or perspective projection shall be used. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a548120a160202248e0cde10f05e01f1b" name="a548120a160202248e0cde10f05e01f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548120a160202248e0cde10f05e01f1b">&#9670;&#160;</a></span>clip_to_screen_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2f eos::render::clip_to_screen_space </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>clip_coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms a point from clip space ([-1, 1] x [-1, 1]) to image (screen) coordinates, i.e. the window transform. Note that the y-coordinate is flipped because the image origin is top-left while in clip space top is +1 and bottom is -1. No z-division is performed. Note: It should rather be called from NDC to screen space?</p>
<p>Exactly conforming to the OpenGL viewport transform, except that we flip y at the end. Qt: Origin top-left. OpenGL: bottom-left. OCV: top-left.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clip_coordinates</td><td>A point in clip coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to screen space. </dd></dl>

</div>
</div>
<a id="a6c9fd3f70cca4fdac35d2a01df36488c" name="a6c9fd3f70cca4fdac35d2a01df36488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9fd3f70cca4fdac35d2a01df36488c">&#9670;&#160;</a></span>compute_face_normal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f eos::render::compute_face_normal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the normal of a face (triangle), i.e. the per-face normal. Returned normal will be unit length.</p>
<p>Assumes the triangle is given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length normal of the given triangle. </dd></dl>

</div>
</div>
<a id="a182473d4bf5ed064098f7733b28001e3" name="a182473d4bf5ed064098f7733b28001e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182473d4bf5ed064098f7733b28001e3">&#9670;&#160;</a></span>compute_face_normal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3f eos::render::compute_face_normal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the normal of a face (triangle), i.e. the per-face normal. Returned normal will be unit length.</p>
<p>Assumes the triangle is given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length normal of the given triangle. </dd></dl>

</div>
</div>
<a id="a52ab153b18b90c00a82b5e30afd52f1d" name="a52ab153b18b90c00a82b5e30afd52f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ab153b18b90c00a82b5e30afd52f1d">&#9670;&#160;</a></span>compute_face_normals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Vector3f &gt; eos::render::compute_face_normals </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_vertex_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the per-face (per-triangle) normals of all triangles of the given mesh. Returned normals will be unit length.</p>
<p>Assumes triangles are given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>A list of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle_vertex_indices</td><td>Triangle list for the given vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length per-face normals. </dd></dl>

</div>
</div>
<a id="aafd18efdff1bf1a2d4713778ef4ba4cb" name="aafd18efdff1bf1a2d4713778ef4ba4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd18efdff1bf1a2d4713778ef4ba4cb">&#9670;&#160;</a></span>compute_inverse_perspectively_correct_lambda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3&lt; T &gt; eos::render::compute_inverse_perspectively_correct_lambda </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda_world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>one_over_w2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes inverse perspectively correct lambda. </p>
<p>X. Inverts the perspective texture mapping. Can be derived using some tedious algebra. Todo: Probably move to a texturing file, internal/detail one, where we will also put the tex2d, mipmapping etc stuff?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>X. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>X. </dd></dl>

</div>
</div>
<a id="aac72e19ce0b13a1d97d5824cfc848796" name="aac72e19ce0b13a1d97d5824cfc848796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac72e19ce0b13a1d97d5824cfc848796">&#9670;&#160;</a></span>compute_per_vertex_self_occlusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; eos::render::compute_per_vertex_self_occlusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>modelview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::RayDirection&#160;</td>
          <td class="paramname"><em>ray_direction_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each given vertex, compute whether it is visible or self-occluded by the mesh formed by the given vertices and triangle indices.</p>
<p>Transforms the vertices into view space first using the given <code>modelview</code> matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>A set of vertices that form a mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle_vertex_indices</td><td>Triangle indices corresponding to the given mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelview</td><td>Model-view matrix, to transform the given vertices from model space to view space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_direction_type</td><td>Whether the occlusion should be computed under orthographic or perspective projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the per-vertex visibility (true if the vertex is visible, false if it is self-occluded). </dd></dl>

</div>
</div>
<a id="a73da7d2bf93f962114a774fefa0ecfd7" name="a73da7d2bf93f962114a774fefa0ecfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73da7d2bf93f962114a774fefa0ecfd7">&#9670;&#160;</a></span>compute_per_vertex_self_occlusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; eos::render::compute_per_vertex_self_occlusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewspace_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::RayDirection&#160;</td>
          <td class="paramname"><em>ray_direction_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For each given vertex, compute whether it is visible or self-occluded by the mesh formed by the given vertices and triangle indices.</p>
<p>The function uses simple ray casting for each vertex, and checks whether each ray intersects any other triangle. Thus, the algorithm can become quite slow for larger meshes. Depending on <code>ray_direction_type</code>, the rays are either casted from each vertex along the positive z axis, or towards the origin (0, 0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">viewspace_vertices</td><td>A set of vertices that form a mesh, in view-space coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle_vertex_indices</td><td>Triangle indices corresponding to the given mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_direction_type</td><td>Whether the occlusion should be computed under orthographic or perspective projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the per-vertex visibility (true if the vertex is visible, false if it is self-occluded). </dd></dl>

</div>
</div>
<a id="aa8a065cfacba7489d406d66fcaa2f231" name="aa8a065cfacba7489d406d66fcaa2f231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a065cfacba7489d406d66fcaa2f231">&#9670;&#160;</a></span>compute_vertex_normals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Vector3f &gt; eos::render::compute_vertex_normals </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangle_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the per-vertex normals of all vertices of the given mesh. Returned normals will be unit length.</p>
<p>Assumes triangles are given in CCW order, i.e. vertices in counterclockwise order on the screen are front-facing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>A list of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle_vertex_indices</td><td>Triangle list for the given vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_normals</td><td>Per-face normals for all triangles. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unit-length per-vertex normals. </dd></dl>

</div>
</div>
<a id="a51aa9b1aa73d0bcb2ee8f911fc4f4d40" name="a51aa9b1aa73d0bcb2ee8f911fc4f4d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51aa9b1aa73d0bcb2ee8f911fc4f4d40">&#9670;&#160;</a></span>draw_line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::draw_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws a line using the Bresenham algorithm.</p>
<p>From: <a href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a> I also tried this: <a href="https://www.thecrazyprogrammer.com/2017/01/bresenhams-line-drawing-algorithm-c-c.html">https://www.thecrazyprogrammer.com/2017/01/bresenhams-line-drawing-algorithm-c-c.html</a> which looks awesome, but it drew weird lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An image to draw into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>X coordinate of the start point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y0</td><td>Y coordinate of the start point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x1</td><td>X coordinate of the start point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y1</td><td>Y coordinate of the end point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>RGB colour of the line to be drawn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c87e64cfa5af1fd1e26b3495f28db98" name="a3c87e64cfa5af1fd1e26b3495f28db98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c87e64cfa5af1fd1e26b3495f28db98">&#9670;&#160;</a></span>draw_texcoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::render::draw_texcoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em> = <code>cv::Mat()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture coordinates (uv-coords) of the given mesh into an image by looping over the triangles and drawing each triangle's texcoords.</p>
<p>Note/Todo: This function has a slight problems, the lines do not actually get drawn blue, if the image is 8UC4. Well if I save a PNG, it is blue. Not sure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An optional image to draw onto. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An image with the texture coordinate triangles drawn in it, 512x512 if no image is given. </dd></dl>

</div>
</div>
<a id="aa5d05494249ceda229d3cacbad5d4363" name="aa5d05494249ceda229d3cacbad5d4363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d05494249ceda229d3cacbad5d4363">&#9670;&#160;</a></span>draw_wireframe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::draw_wireframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image3u</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>modelview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f&#160;</td>
          <td class="paramname"><em>color</em> = <code>Eigen::Vector3f(0,&#160;255,&#160;0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the given mesh as wireframe into the image.</p>
<p>It does backface culling, i.e. draws only vertices in CCW order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An image to draw into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelview</td><td>Model-view matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>Projection matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Viewport to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>Colour of the mesh to be drawn, in RGB. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b2dc90d646185cf9e09b2b21c91f9e" name="a13b2dc90d646185cf9e09b2b21c91f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b2dc90d646185cf9e09b2b21c91f9e">&#9670;&#160;</a></span>draw_wireframe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::render::draw_wireframe </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>modelview</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4f&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Scalar&#160;</td>
          <td class="paramname"><em>color</em> = <code>cv::Scalar(0,&#160;255,&#160;0,&#160;255)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the given mesh as wireframe into the image.</p>
<p>It does backface culling, i.e. draws only vertices in CCW order.</p>
<p>Note: This function might be deprecated in the future, in favour of draw_wireframe(...) in <a class="el" href="draw__utils_8hpp_source.html">render/draw_utils.hpp</a>, which doesn't depend on OpenCV anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>An image to draw into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to draw. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelview</td><td>Model-view matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection</td><td>Projection matrix to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Viewport to draw the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>Colour of the mesh to be drawn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01d12e5339e0b016ead391ebc9cc79e6" name="a01d12e5339e0b016ead391ebc9cc79e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d12e5339e0b016ead391ebc9cc79e6">&#9670;&#160;</a></span>extract_texture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1core_1_1_image.html">eos::core::Image4u</a> eos::render::extract_texture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>view_model_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix4f&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceeos_1_1render.html#a7b89db196c55aa0b6365200b2b1ddd13">ProjectionType</a>&#160;</td>
          <td class="paramname"><em>projection_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_image.html">eos::core::Image4u</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>texturemap_resolution</em> = <code>512</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the texture from the given image and returns a texture map. </p>
<p>Remaps the texture from the given <code>image</code>, using the given <code>mesh</code>, projection matrices, and the mesh's uv coordinates, to a texture map.</p>
<p>Notes &amp; todo's:</p><ul>
<li>The function does currently not compute a view-angle and store that in the alpha channel, like the previous function did. We have to re-add that. Documentation of the old parameter: `compute_view_angle A flag whether the view angle of each vertex should be computed and returned. If set to true, the angle will be encoded into the alpha channel (0 meaning occluded or facing away 90°, 127 meaning facing a 45° angle and 255 meaning front-facing, and all values in between). If set to false, the alpha channel will only contain 0 for occluded vertices and 255 for visible vertices.<code></code></li>
<li><code>We perhaps should add another parameter,</code>Eigen::Vector4 viewport<code>. We could need to change </code><a class="el" href="namespaceeos_1_1render.html#a548120a160202248e0cde10f05e01f1b">clip_to_screen_space()</a><code>to make use of that.</code></li>
<li><code>Perhaps add an overload that takes a</code>vector&lt;bool&gt; visible vertices`, for the case when we already computed the visibility? (e.g. from the edge-fitting)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A mesh with texture coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view_model_matrix</td><td>Model-view matrix, to bring the mesh into view-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>Projection matrix, to bring the mesh into clip-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_type</td><td>Indicates whether the projection used is orthographic or perspective. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The image to extract the texture from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texturemap_resolution</td><td>The resolution of the generated texture map. Defaults to 512x512. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classeos_1_1render_1_1_texture.html" title="Represents a texture for rendering.">Texture</a> map with the extracted texture. </dd></dl>

</div>
</div>
<a id="a6937bd32bc52fcc61b40fa1587fb9307" name="a6937bd32bc52fcc61b40fa1587fb9307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6937bd32bc52fcc61b40fa1587fb9307">&#9670;&#160;</a></span>is_vertex_visible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool eos::render::is_vertex_visible </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>probe_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3f &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; int, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_triangle_vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">detail::RayDirection&#160;</td>
          <td class="paramname"><em>ray_direction_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes whether the given <code>probe_vertex</code> is visible or self-occluded by the mesh formed by the given vertices and triangle indices.</p>
<p>The function uses simple ray casting and checks whether the ray intersects any triangle of the given mesh. Thus, the algorithm can become quite slow for larger meshes. Depending on <code>ray_direction_type</code>, the rays are either casted from each vertex along the positive z axis, or towards the origin (0, 0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">probe_vertex</td><td>A single vertex to compute the visibility for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_vertices</td><td>A set of vertices that form a mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_triangle_vertex_indices</td><td>Triangle indices corresponding to the given mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_direction_type</td><td>Whether the occlusion should be computed under orthographic or perspective projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns whether the given vertex is visible (true if the vertex is visible, false if it is self-occluded). </dd></dl>

</div>
</div>
<a id="a148b6d7384a192326576430c64e10595" name="a148b6d7384a192326576430c64e10595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148b6d7384a192326576430c64e10595">&#9670;&#160;</a></span>ortho() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4&lt; T &gt; eos::render::ortho </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2D orthographic projection matrix. </p>
<p>This function sets up a two-dimensional orthographic viewing region. This is equivalent to calling glOrtho with near=-1 and far=1. The function is equivalent to glm::orthoRH_NO(), but with near=-1 and far=1.</p>
<p>More details can be found on the gluOrtho2D man page: <a href="https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/gluOrtho2D.xml">https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/gluOrtho2D.xml</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Specifies the coordinates for the left vertical clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Specifies the coordinates for the right vertical clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Specifies the coordinates for the bottom horizontal clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Specifies the coordinates for the top horizontal clipping plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating-point scalar type, ceres::Jet, or similar compatible type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding orthographic projection matrix. </dd></dl>

</div>
</div>
<a id="a2a22b899d57fd3e472910241f5592487" name="a2a22b899d57fd3e472910241f5592487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a22b899d57fd3e472910241f5592487">&#9670;&#160;</a></span>ortho() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4&lt; T &gt; eos::render::ortho </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z_near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z_far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a matrix for an orthographic parallel viewing volume, using right-handed coordinates. </p>
<p>The function follows the OpenGL clip volume definition, which is also the GLM default. The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.</p>
<p>The function is equivalent to glm::orthoRH_NO(...).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Specifies the coordinates for the left vertical clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Specifies the coordinates for the right vertical clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Specifies the coordinates for the bottom horizontal clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>Specifies the coordinates for the top horizontal clipping plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_near</td><td>Specifies the distance from the viewer to the near clipping plane (always positive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_far</td><td>Specifies the distance from the viewer to the far clipping plane (always positive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating-point scalar type, ceres::Jet, or similar compatible type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding orthographic projection matrix. </dd></dl>

</div>
</div>
<a id="a55b47fe0990755fdd540b97cc77a8a1b" name="a55b47fe0990755fdd540b97cc77a8a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b47fe0990755fdd540b97cc77a8a1b">&#9670;&#160;</a></span>perspective()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4&lt; T &gt; eos::render::perspective </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>fov_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z_near</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z_far</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a matrix for a right-handed, symmetric perspective-view frustum.</p>
<p>The function follows the OpenGL clip volume definition, which is also the GLM default. The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively.</p>
<p>This function is equivalent to glm::perspectiveRH_NO(...).</p>
<p>More details can be found on the gluPerspective man page: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fov_y</td><td>Specifies the field of view angle in the y direction. Expressed in radians. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aspect</td><td>Specifies the aspect ratio that determines the field of view in the x direction. The aspect ratio is the ratio of x (width) to y (height). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_near</td><td>Specifies the distance from the viewer to the near clipping plane (always positive). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z_far</td><td>Specifies the distance from the viewer to the far clipping plane (always positive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating-point scalar type, ceres::Jet, or similar compatible type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding perspective projection matrix. </dd></dl>

</div>
</div>
<a id="a91f10062952969ca3fba1d94c8f77692" name="a91f10062952969ca3fba1d94c8f77692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91f10062952969ca3fba1d94c8f77692">&#9670;&#160;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3&lt; T &gt; eos::render::project </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>modelview_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project the given point_3d (from object coordinates) into window coordinates.</p>
<p>The function follows the OpenGL clip volume definition. The near and far clip planes correspond to z normalized device coordinates of -1 and +1 respectively. This function is equivalent to glm::projectNO(...).</p>
<p>More details can be found on the gluProject man page: <a href="https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluProject.xml">https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluProject.xml</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point_3d</td><td>A 3D point in object coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">modelview_matrix</td><td>A model-view matrix, transforming the point into view (camera) space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>The projection matrix to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>The viewport transformation to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A floating-point scalar type, ceres::Jet, or similar compatible type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the computed window coordinates. </dd></dl>

</div>
</div>
<a id="a26a18dc1026bffbba577dfe4b3198d12" name="a26a18dc1026bffbba577dfe4b3198d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a18dc1026bffbba577dfe4b3198d12">&#9670;&#160;</a></span>ray_triangle_intersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, cpp17::optional&lt; float &gt; &gt; eos::render::ray_triangle_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>ray_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backculling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of the given ray with the given triangle. </p>
<p>Uses the Möller-Trumbore algorithm "Fast Minimum Storage Ray/Triangle Intersection". Independent implementation, inspired by: <a href="http://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection">http://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection</a> The default eps (1e-6f) is from the paper. When culling is on, rays intersecting triangles from the back will be discarded - otherwise, the triangles normal direction w.r.t. the ray direction is just ignored.</p>
<p>Todo: We don't need the pair&lt;&gt; here, we could just return optional&lt;float&gt;. Also, I hope optional wouldn't be a performance problem here, as this function is called loads of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_origin</td><td>Ray origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_direction</td><td>Ray direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backculling</td><td>When culling is on, rays intersecting triangles from the back will be discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the ray intersects the triangle, and if yes, including the distance. </dd></dl>

</div>
</div>
<a id="ae7c27ad77dc83d41ee3f885bf8434d69" name="ae7c27ad77dc83d41ee3f885bf8434d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c27ad77dc83d41ee3f885bf8434d69">&#9670;&#160;</a></span>render() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a> eos::render::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model_view_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backface_culling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_near_clipping</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_far_clipping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that renders the given mesh onto a 2D image using <code><a class="el" href="classeos_1_1render_1_1_software_renderer.html" title="X.">SoftwareRenderer</a></code>. Conforms to OpenGL conventions.</p>
<p>Renders using per-vertex colouring, without texturing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_view_matrix</td><td>A 4x4 OpenGL model-view matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>A 4x4 orthographic or perspective OpenGL projection matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backface_culling</td><td>Whether the renderer should perform backface culling. If true, only draw triangles with vertices ordered CCW in screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_near_clipping</td><td>Whether vertices should be clipped against the near plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_far_clipping</td><td>Whether vertices should be clipped against the far plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Framebuffer (colourbuffer) with the rendered image. </dd></dl>

</div>
</div>
<a id="ad344b915901f03cd523c9c6a3496a01a" name="ad344b915901f03cd523c9c6a3496a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad344b915901f03cd523c9c6a3496a01a">&#9670;&#160;</a></span>render() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1core_1_1_image.html">core::Image4u</a> eos::render::render </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model_view_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>viewport_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeos_1_1render_1_1_texture.html">Texture</a>&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backface_culling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_near_clipping</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_far_clipping</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that renders the given mesh onto a 2D image using <code><a class="el" href="classeos_1_1render_1_1_software_renderer.html" title="X.">SoftwareRenderer</a></code>. Conforms to OpenGL conventions.</p>
<p>Performs texturing using the given <code>texture</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>A 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_view_matrix</td><td>A 4x4 OpenGL model-view matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">projection_matrix</td><td>A 4x4 orthographic or perspective OpenGL projection matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_width</td><td>Screen width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Screen height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>A texture map to texture the model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backface_culling</td><td>Whether the renderer should perform backface culling. If true, only draw triangles with vertices ordered CCW in screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_near_clipping</td><td>Whether vertices should be clipped against the near plane. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_far_clipping</td><td>Whether vertices should be clipped against the far plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Framebuffer (colourbuffer) with the rendered image. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>

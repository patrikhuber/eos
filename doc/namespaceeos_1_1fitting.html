<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eos: eos::fitting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eos
   &#160;<span id="projectnumber">0.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="namespaceeos_1_1fitting.html">fitting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eos::fitting Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Pose and shape fitting of a 3D Morphable Model.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">ContourLandmarks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines which 2D landmarks comprise the right and left face contour.  <a href="structeos_1_1fitting_1_1_contour_landmarks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_fitting_result.html">FittingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct holding the result from a fitting.  <a href="structeos_1_1fitting_1_1_fitting_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a camera viewing frustum. At the moment only fully tested with orthographic camera.  <a href="structeos_1_1fitting_1_1_frustum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_image_cost.html">ImageCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_k_d_tree_vector_of_vectors_adaptor.html">KDTreeVectorOfVectorsAdaptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_landmark_cost.html">LandmarkCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_model_contour.html">ModelContour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the vertex indices that define the right and left model contour.  <a href="structeos_1_1fitting_1_1_model_contour.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_prior_cost.html">PriorCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of estimated model parameters (rotation, translation) and camera parameters (viewing frustum).  <a href="classeos_1_1fitting_1_1_rendering_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_scaled_ortho_projection_parameters.html">ScaledOrthoProjectionParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a63fce336daef96cde45f61701c4a3cf4"><td class="memItemLeft" align="right" valign="top"><a id="a63fce336daef96cde45f61701c4a3cf4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CameraType</b> { <b>Orthographic</b>, 
<b>Perspective</b>
 }</td></tr>
<tr class="separator:a63fce336daef96cde45f61701c4a3cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afce5f7297094056a04ad26785c94bbd8"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#afce5f7297094056a04ad26785c94bbd8">estimate_affine_camera</a> (std::vector&lt; cv::Vec2f &gt; image_points, std::vector&lt; cv::Vec4f &gt; model_points)</td></tr>
<tr class="separator:afce5f7297094056a04ad26785c94bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e99a34e412f0bb5b2c6568dd37ae413"><td class="memItemLeft" align="right" valign="top">cv::Vec2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a3e99a34e412f0bb5b2c6568dd37ae413">project_affine</a> (cv::Vec4f vertex, cv::Mat affine_camera_matrix, int screen_width, int screen_height)</td></tr>
<tr class="separator:a3e99a34e412f0bb5b2c6568dd37ae413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d28c44f5ac118eb15c1626e7aa0730"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a95d28c44f5ac118eb15c1626e7aa0730">fit_blendshapes_to_landmarks_linear</a> (const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const Eigen::VectorXf &amp;face_instance, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const std::vector&lt; Eigen::Vector2f &gt; &amp;landmarks, const std::vector&lt; int &gt; &amp;vertex_ids, float lambda=500.0f)</td></tr>
<tr class="separator:a95d28c44f5ac118eb15c1626e7aa0730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a525814be9d4051deab4032344cdc6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a2a525814be9d4051deab4032344cdc6e">fit_blendshapes_to_landmarks_nnls</a> (const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const Eigen::VectorXf &amp;face_instance, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const std::vector&lt; Eigen::Vector2f &gt; &amp;landmarks, const std::vector&lt; int &gt; &amp;vertex_ids)</td></tr>
<tr class="separator:a2a525814be9d4051deab4032344cdc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbd14805664180f3eca321aa8be8c0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8cbd14805664180f3eca321aa8be8c0d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a8cbd14805664180f3eca321aa8be8c0d">get_shape_point</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;shape_model, const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, int vertex_id, const T *const shape_coeffs, const T *const blendshape_coeffs)</td></tr>
<tr class="separator:a8cbd14805664180f3eca321aa8be8c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cd220776a04f2738b80930c1cc70a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80cd220776a04f2738b80930c1cc70a7"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a80cd220776a04f2738b80930c1cc70a7">get_vertex_colour</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;colour_model, int vertex_id, const T *const colour_coeffs)</td></tr>
<tr class="separator:a80cd220776a04f2738b80930c1cc70a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6224885ee6804c12195f04a4b7206f2f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, cpp17::optional&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a6224885ee6804c12195f04a4b7206f2f">ray_triangle_intersect</a> (const glm::vec3 &amp;ray_origin, const glm::vec3 &amp;ray_direction, const glm::vec3 &amp;v0, const glm::vec3 &amp;v1, const glm::vec3 &amp;v2, bool enable_backculling)</td></tr>
<tr class="memdesc:a6224885ee6804c12195f04a4b7206f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of the given ray with the given triangle.  <a href="#a6224885ee6804c12195f04a4b7206f2f">More...</a><br /></td></tr>
<tr class="separator:a6224885ee6804c12195f04a4b7206f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ab38e4c0c16cd94655c7010f97390"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#aa51ab38e4c0c16cd94655c7010f97390">occluding_boundary_vertices</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, glm::mat4x4 R)</td></tr>
<tr class="memdesc:aa51ab38e4c0c16cd94655c7010f97390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vertices that lie on occluding boundaries, given a particular pose.  <a href="#aa51ab38e4c0c16cd94655c7010f97390">More...</a><br /></td></tr>
<tr class="separator:aa51ab38e4c0c16cd94655c7010f97390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0ef191ea599eab3e17f4a21f7832d4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; Eigen::Vector2f &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a1b0ef191ea599eab3e17f4a21f7832d4">find_occluding_edge_correspondences</a> (const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, const <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &amp;rendering_parameters, const std::vector&lt; Eigen::Vector2f &gt; &amp;image_edges, float distance_threshold=64.0f)</td></tr>
<tr class="memdesc:a1b0ef191ea599eab3e17f4a21f7832d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given list of 2D edge points, find corresponding 3D vertex IDs.  <a href="#a1b0ef191ea599eab3e17f4a21f7832d4">More...</a><br /></td></tr>
<tr class="separator:a1b0ef191ea599eab3e17f4a21f7832d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a307eaa4a1a9f2c5e2c33a95a6e261d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a6a307eaa4a1a9f2c5e2c33a95a6e261d">select_contour</a> (float yaw_angle, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">ModelContour</a> &amp;model_contour)</td></tr>
<tr class="separator:a6a307eaa4a1a9f2c5e2c33a95a6e261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b82996959bc351f7fb2afd72a701b9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; Eigen::Vector2f &gt;, std::vector&lt; Eigen::Vector4f &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a39b82996959bc351f7fb2afd72a701b9">get_nearest_contour_correspondences</a> (const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;landmarks, const std::vector&lt; std::string &gt; &amp;landmark_contour_identifiers, const std::vector&lt; int &gt; &amp;model_contour_indices, const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const glm::mat4x4 &amp;view_model, const glm::mat4x4 &amp;ortho_projection, const glm::vec4 &amp;viewport)</td></tr>
<tr class="separator:a39b82996959bc351f7fb2afd72a701b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140ead165ca9fc56180ad938cfc37efd"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; Eigen::Vector2f &gt;, std::vector&lt; Eigen::Vector4f &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a140ead165ca9fc56180ad938cfc37efd">get_contour_correspondences</a> (const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;landmarks, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">ModelContour</a> &amp;model_contour, float yaw_angle, const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;mesh, const glm::mat4x4 &amp;view_model, const glm::mat4x4 &amp;ortho_projection, const glm::vec4 &amp;viewport)</td></tr>
<tr class="separator:a140ead165ca9fc56180ad938cfc37efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06c5811029231027356c9674f1cf08f"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#ab06c5811029231027356c9674f1cf08f">fit_shape</a> (Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const std::vector&lt; Eigen::Vector2f &gt; &amp;image_points, const std::vector&lt; int &gt; &amp;vertex_indices, float lambda, cpp17::optional&lt; int &gt; num_coefficients_to_fit, std::vector&lt; float &gt; &amp;pca_shape_coefficients, std::vector&lt; float &gt; &amp;blendshape_coefficients)</td></tr>
<tr class="separator:ab06c5811029231027356c9674f1cf08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ab5ec634807ac639cd500e04fdbb70"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#aa6ab5ec634807ac639cd500e04fdbb70">fit_shape</a> (Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const std::vector&lt; Eigen::Vector2f &gt; &amp;image_points, const std::vector&lt; int &gt; &amp;vertex_indices, float lambda=3.0f, cpp17::optional&lt; int &gt; num_coefficients_to_fit=cpp17::optional&lt; int &gt;())</td></tr>
<tr class="separator:aa6ab5ec634807ac639cd500e04fdbb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cb82b9f04cb095e9e763672b358018"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a73cb82b9f04cb095e9e763672b358018"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a73cb82b9f04cb095e9e763672b358018">get_corresponding_pointset</a> (const T &amp;landmarks, const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;landmark_mapper, const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model)</td></tr>
<tr class="memdesc:a73cb82b9f04cb095e9e763672b358018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a LandmarkCollection of 2D landmarks and, using the landmark_mapper, finds the corresponding 3D vertex indices and returns them, along with the coordinates of the 3D points.  <a href="#a73cb82b9f04cb095e9e763672b358018">More...</a><br /></td></tr>
<tr class="separator:a73cb82b9f04cb095e9e763672b358018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca8617e85d5eddca89cba30bb909969"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ca8617e85d5eddca89cba30bb909969"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a7ca8617e85d5eddca89cba30bb909969">concat</a> (const std::vector&lt; T &gt; &amp;vec_a, const std::vector&lt; T &gt; &amp;vec_b)</td></tr>
<tr class="memdesc:a7ca8617e85d5eddca89cba30bb909969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two std::vector's of the same type and returns the concatenated vector. The elements of the second vector are appended after the first one.  <a href="#a7ca8617e85d5eddca89cba30bb909969">More...</a><br /></td></tr>
<tr class="separator:a7ca8617e85d5eddca89cba30bb909969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a38ffb693a9ab456d4e0d773aeb51a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a8a38ffb693a9ab456d4e0d773aeb51a5">fit_expressions</a> (const <a class="el" href="namespaceeos_1_1morphablemodel.html#a13ad48bb1ba963a9a8f2c360be701a40">morphablemodel::ExpressionModel</a> &amp;expression_model, const Eigen::VectorXf &amp;face_instance, const Eigen::Matrix&lt; float, 3, 4 &gt; &amp;affine_camera_matrix, const std::vector&lt; Eigen::Vector2f &gt; &amp;landmarks, const std::vector&lt; int &gt; &amp;vertex_ids, cpp17::optional&lt; float &gt; lambda_expressions=cpp17::optional&lt; float &gt;(), cpp17::optional&lt; int &gt; num_expression_coefficients_to_fit=cpp17::optional&lt; int &gt;())</td></tr>
<tr class="memdesc:a8a38ffb693a9ab456d4e0d773aeb51a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits the given expression model to landmarks.  <a href="#a8a38ffb693a9ab456d4e0d773aeb51a5">More...</a><br /></td></tr>
<tr class="separator:a8a38ffb693a9ab456d4e0d773aeb51a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44553df236553dcceeae64d9128c6d69"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a44553df236553dcceeae64d9128c6d69">fit_shape_and_pose</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;landmarks, const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;landmark_mapper, int image_width, int image_height, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;model_contour, int num_iterations, cpp17::optional&lt; int &gt; num_shape_coefficients_to_fit, float lambda_identity, cpp17::optional&lt; int &gt; num_expression_coefficients_to_fit, cpp17::optional&lt; float &gt; lambda_expressions, cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt; initial_rendering_params, std::vector&lt; float &gt; &amp;pca_shape_coefficients, std::vector&lt; float &gt; &amp;expression_coefficients, std::vector&lt; Eigen::Vector2f &gt; &amp;fitted_image_points)</td></tr>
<tr class="memdesc:a44553df236553dcceeae64d9128c6d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way.  <a href="#a44553df236553dcceeae64d9128c6d69">More...</a><br /></td></tr>
<tr class="separator:a44553df236553dcceeae64d9128c6d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9dd151a721a9c15e98fd8ad0e8de65a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#ab9dd151a721a9c15e98fd8ad0e8de65a">fit_shape_and_pose</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;landmarks, const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;landmark_mapper, int image_width, int image_height, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;model_contour, int num_iterations=5, cpp17::optional&lt; int &gt; num_shape_coefficients_to_fit=cpp17::nullopt, float lambda_identity=50.0f, cpp17::optional&lt; int &gt; num_expression_coefficients_to_fit=cpp17::nullopt, cpp17::optional&lt; float &gt; lambda_expressions=cpp17::nullopt)</td></tr>
<tr class="memdesc:ab9dd151a721a9c15e98fd8ad0e8de65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way.  <a href="#ab9dd151a721a9c15e98fd8ad0e8de65a">More...</a><br /></td></tr>
<tr class="separator:ab9dd151a721a9c15e98fd8ad0e8de65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d6849dadaa06ace1d69d5600f85cb2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a74d6849dadaa06ace1d69d5600f85cb2">fit_shape_and_pose</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const std::vector&lt; Eigen::Vector2f &gt; &amp;image_points, const std::vector&lt; int &gt; &amp;vertex_indices, int image_width, int image_height, int num_iterations, cpp17::optional&lt; int &gt; num_shape_coefficients_to_fit, float lambda_identity, cpp17::optional&lt; int &gt; num_expression_coefficients_to_fit, cpp17::optional&lt; float &gt; lambda_expressions, cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt; initial_rendering_params, std::vector&lt; float &gt; &amp;pca_shape_coefficients, std::vector&lt; float &gt; &amp;expression_coefficients, std::vector&lt; Eigen::Vector2f &gt; &amp;fitted_image_points)</td></tr>
<tr class="memdesc:a74d6849dadaa06ace1d69d5600f85cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way.  <a href="#a74d6849dadaa06ace1d69d5600f85cb2">More...</a><br /></td></tr>
<tr class="separator:a74d6849dadaa06ace1d69d5600f85cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f844c8d820313b3cfe8ab0b7e740c0a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a9f844c8d820313b3cfe8ab0b7e740c0a">fit_shape_to_landmarks_linear</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;shape_model, Eigen::Matrix&lt; float, 3, 4 &gt; affine_camera_matrix, const std::vector&lt; Eigen::Vector2f &gt; &amp;landmarks, const std::vector&lt; int &gt; &amp;vertex_ids, Eigen::VectorXf base_face=Eigen::VectorXf(), float lambda=3.0f, cpp17::optional&lt; int &gt; num_coefficients_to_fit=cpp17::optional&lt; int &gt;(), cpp17::optional&lt; float &gt; detector_standard_deviation=cpp17::optional&lt; float &gt;(), cpp17::optional&lt; float &gt; model_standard_deviation=cpp17::optional&lt; float &gt;())</td></tr>
<tr class="separator:a9f844c8d820313b3cfe8ab0b7e740c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193b0cb88e23a6870304f0b68ed230cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a193b0cb88e23a6870304f0b68ed230cd">fit_shape_to_landmarks_linear_multi</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;shape_model, const std::vector&lt; Eigen::Matrix&lt; float, 3, 4 &gt;&gt; &amp;affine_camera_matrices, const std::vector&lt; std::vector&lt; Eigen::Vector2f &gt;&gt; &amp;landmarks, const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;vertex_ids, std::vector&lt; Eigen::VectorXf &gt; base_faces=std::vector&lt; Eigen::VectorXf &gt;(), float lambda=3.0f, cpp17::optional&lt; int &gt; num_coefficients_to_fit=cpp17::optional&lt; int &gt;(), cpp17::optional&lt; float &gt; detector_standard_deviation=cpp17::optional&lt; float &gt;(), cpp17::optional&lt; float &gt; model_standard_deviation=cpp17::optional&lt; float &gt;())</td></tr>
<tr class="separator:a193b0cb88e23a6870304f0b68ed230cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3bf7d03ccc43f85b0311c9469e8c31"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &gt;, std::vector&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#aee3bf7d03ccc43f85b0311c9469e8c31">fit_shape_and_pose</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const std::vector&lt; <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt;&gt; &amp;landmarks, const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;landmark_mapper, std::vector&lt; int &gt; image_width, std::vector&lt; int &gt; image_height, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;model_contour, int num_iterations, cpp17::optional&lt; int &gt; num_shape_coefficients_to_fit, float lambda, cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt; initial_rendering_params, std::vector&lt; float &gt; &amp;pca_shape_coefficients, std::vector&lt; std::vector&lt; float &gt;&gt; &amp;blendshape_coefficients, std::vector&lt; std::vector&lt; Eigen::Vector2f &gt;&gt; &amp;fitted_image_points)</td></tr>
<tr class="memdesc:aee3bf7d03ccc43f85b0311c9469e8c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. This function takes a set of images and landmarks and estimates per-frame pose and expressions, as well as identity shape jointly from all images.  <a href="#aee3bf7d03ccc43f85b0311c9469e8c31">More...</a><br /></td></tr>
<tr class="separator:aee3bf7d03ccc43f85b0311c9469e8c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06cbad9ff38bdbb898f9df170b616a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector&lt; <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &gt;, std::vector&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#ae06cbad9ff38bdbb898f9df170b616a2">fit_shape_and_pose</a> (const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;morphable_model, const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;blendshapes, const std::vector&lt; <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt;&gt; &amp;landmarks, const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;landmark_mapper, std::vector&lt; int &gt; image_width, std::vector&lt; int &gt; image_height, const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;edge_topology, const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;contour_landmarks, const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;model_contour, int num_iterations=5, cpp17::optional&lt; int &gt; num_shape_coefficients_to_fit=cpp17::nullopt, float lambda=30.0f)</td></tr>
<tr class="memdesc:ae06cbad9ff38bdbb898f9df170b616a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. This function takes a set of images and landmarks and estimates per-frame pose and expressions, as well as identity shape jointly from all images.  <a href="#ae06cbad9ff38bdbb898f9df170b616a2">More...</a><br /></td></tr>
<tr class="separator:ae06cbad9ff38bdbb898f9df170b616a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f55324bfa740c6b5061518535506084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a9f55324bfa740c6b5061518535506084">estimate_orthographic_camera</a> (std::vector&lt; cv::Vec2f &gt; image_points, std::vector&lt; cv::Vec4f &gt; model_points, int width, int height)</td></tr>
<tr class="memdesc:a9f55324bfa740c6b5061518535506084"><td class="mdescLeft">&#160;</td><td class="mdescRight">This algorithm estimates the rotation angles and translation of the model, as well as the viewing frustum of the camera, given a set of corresponding 2D-3D points.  <a href="#a9f55324bfa740c6b5061518535506084">More...</a><br /></td></tr>
<tr class="separator:a9f55324bfa740c6b5061518535506084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078caabb9340312418036c557348a07c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structeos_1_1fitting_1_1_scaled_ortho_projection_parameters.html">ScaledOrthoProjectionParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a078caabb9340312418036c557348a07c">estimate_orthographic_projection_linear</a> (std::vector&lt; Eigen::Vector2f &gt; image_points, std::vector&lt; Eigen::Vector4f &gt; model_points, bool is_viewport_upsidedown, cpp17::optional&lt; int &gt; viewport_height=cpp17::nullopt)</td></tr>
<tr class="separator:a078caabb9340312418036c557348a07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b4bc35b0619e7f4bd0fccbb2d35e2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a03b4bc35b0619e7f4bd0fccbb2d35e2c">save_rendering_parameters</a> (<a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a> rendering_parameters, std::string filename)</td></tr>
<tr class="separator:a03b4bc35b0619e7f4bd0fccbb2d35e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e713b5555396806a9b26817184eacd0"><td class="memItemLeft" align="right" valign="top"><a id="a4e713b5555396806a9b26817184eacd0"></a>
glm::vec4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a4e713b5555396806a9b26817184eacd0">get_opencv_viewport</a> (int width, int height)</td></tr>
<tr class="memdesc:a4e713b5555396806a9b26817184eacd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a glm/OpenGL compatible viewport vector that flips y and has the origin on the top-left, like in OpenCV. <br /></td></tr>
<tr class="separator:a4e713b5555396806a9b26817184eacd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c824c19fe9ef8a208d0d73360b71159"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; float, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a1c824c19fe9ef8a208d0d73360b71159">to_eigen</a> (const glm::mat4x4 &amp;glm_matrix)</td></tr>
<tr class="memdesc:a1c824c19fe9ef8a208d0d73360b71159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a glm::mat4x4 to an Eigen::Matrix&lt;float, 4, 4&gt;.  <a href="#a1c824c19fe9ef8a208d0d73360b71159">More...</a><br /></td></tr>
<tr class="separator:a1c824c19fe9ef8a208d0d73360b71159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae171e545d0896a74976e2d9a62369370"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#ae171e545d0896a74976e2d9a62369370">get_3x4_affine_camera_matrix</a> (<a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a> params, int width, int height)</td></tr>
<tr class="memdesc:ae171e545d0896a74976e2d9a62369370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3x4 affine camera matrix from given fitting parameters. The matrix transforms points directly from model-space to screen-space.  <a href="#ae171e545d0896a74976e2d9a62369370">More...</a><br /></td></tr>
<tr class="separator:ae171e545d0896a74976e2d9a62369370"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pose and shape fitting of a 3D Morphable Model. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7ca8617e85d5eddca89cba30bb909969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca8617e85d5eddca89cba30bb909969">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eos::fitting::concat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenates two std::vector's of the same type and returns the concatenated vector. The elements of the second vector are appended after the first one. </p>
<p>Note: Move to detail namespace? It's used for the contour fitting, but doesn't really belong here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_a</td><td>First vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec_b</td><td>Second vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated vector. </dd></dl>

</div>
</div>
<a id="afce5f7297094056a04ad26785c94bbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce5f7297094056a04ad26785c94bbd8">&#9670;&nbsp;</a></span>estimate_affine_camera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::fitting::estimate_affine_camera </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec2f &gt;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4f &gt;&#160;</td>
          <td class="paramname"><em>model_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Gold Standard Algorithm for estimating an affine camera matrix from world to image correspondences. See Algorithm 7.2 in Multiple View Geometry, Hartley &amp; Zisserman, 2nd Edition, 2003.</p>
<p>Requires &gt;= 4 corresponding points.</p>
<p>The estimated camera matrix works together with render::render_affine(Mesh, cv::Mat, int, int, bool) to for example render the model or extract texture from the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>A list of 2D image points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_points</td><td>Corresponding points of a 3D model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3x4 affine camera matrix (the third row is [0, 0, 0, 1]). </dd></dl>

</div>
</div>
<a id="a9f55324bfa740c6b5061518535506084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f55324bfa740c6b5061518535506084">&#9670;&nbsp;</a></span>estimate_orthographic_camera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a> eos::fitting::estimate_orthographic_camera </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec2f &gt;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4f &gt;&#160;</td>
          <td class="paramname"><em>model_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This algorithm estimates the rotation angles and translation of the model, as well as the viewing frustum of the camera, given a set of corresponding 2D-3D points. </p>
<p>It assumes an orthographic camera and estimates 6 parameters, [r_x, r_y, r_z, t_x, t_y, frustum_scale], where the first five describe how to transform the model, and the last one describes the cameras viewing frustum (see CameraParameters). This 2D-3D correspondence problem is solved using Eigen's LevenbergMarquardt algorithm.</p>
<p>The method is slightly inspired by "Computer Vision: Models Learning and Inference", Simon J.D. Prince, 2012, but different in a lot of respects.</p>
<p>Eigen's LM implementation requires at least 6 data points, so we require &gt;= 6 corresponding points.</p>
<p>Notes/improvements: The algorithm works reliable as it is, however, it could be improved with the following:</p><ul>
<li>A better initial guess (see e.g. Prince)</li>
<li>We could add a parameter to pass an initial guess</li>
<li>Using the analytic derivatives instead of Eigen::NumericalDiff - they're easy to calculate.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>A list of 2D image points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_points</td><td>Corresponding points of a 3D model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image (or viewport). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image (or viewport). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated model and camera parameters. </dd></dl>

</div>
</div>
<a id="a078caabb9340312418036c557348a07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078caabb9340312418036c557348a07c">&#9670;&nbsp;</a></span>estimate_orthographic_projection_linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeos_1_1fitting_1_1_scaled_ortho_projection_parameters.html">ScaledOrthoProjectionParameters</a> eos::fitting::estimate_orthographic_projection_linear </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Eigen::Vector2f &gt;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector4f &gt;&#160;</td>
          <td class="paramname"><em>model_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_viewport_upsidedown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>viewport_height</em> = <code>cpp17::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Estimates the parameters of a scaled orthographic projection.</p>
<p>Given a set of 2D-3D correspondences, this algorithm estimates rotation, translation (in x and y) and a scaling parameters of the scaled orthographic projection model using a closed-form solution. It does so by first computing an affine camera matrix using algorithm [1], and then finds the closest orthonormal matrix to the estimated affine transform using SVD. This algorithm follows the original implementation <a href="https://github.com/waps101/3DMM_edges/blob/master/utils/POS.m">2</a> of William Smith, University of York.</p>
<p>Requires &gt;= 4 corresponding points.</p>
<p>[1]: Gold Standard Algorithm for estimating an affine camera matrix from world to image correspondences, Algorithm 7.2 in Multiple View Geometry, Hartley &amp; Zisserman, 2nd Edition, 2003.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>A list of 2D image points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_points</td><td>Corresponding points of a 3D model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_viewport_upsidedown</td><td>Flag to set whether the viewport of the image points is upside-down (e.g. as in OpenCV). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport_height</td><td>Height of the viewport of the image points (needs to be given if is_viewport_upsidedown == true). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotation, translation and scaling of the estimated scaled orthographic projection. </dd></dl>

</div>
</div>
<a id="a1b0ef191ea599eab3e17f4a21f7832d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0ef191ea599eab3e17f4a21f7832d4">&#9670;&nbsp;</a></span>find_occluding_edge_correspondences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;Eigen::Vector2f&gt;, std::vector&lt;int&gt; &gt; eos::fitting::find_occluding_edge_correspondences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>rendering_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distance_threshold</em> = <code>64.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given list of 2D edge points, find corresponding 3D vertex IDs. </p>
<p>This algorithm first computes the 3D mesh's occluding boundary vertices under the given pose. Then, for each 2D image edge point given, it searches for the closest 3D edge vertex (projected to 2D). Correspondences lying further away than <code>distance_threshold</code> (times a scale-factor) are discarded. It returns a list of the remaining image edge points and their corresponding 3D vertex ID.</p>
<p>The given <code>rendering_parameters</code> camery_type must be CameraType::Orthographic.</p>
<p>The units of <code>distance_threshold</code> are somewhat complicated. The function uses squared distances, and the <code>distance_threshold</code> is further multiplied with a face-size and image resolution dependent scale factor. It's reasonable to use correspondences that are 10 to 15 pixels away on a 1280x720 image with s=0.93. This would be a distance_threshold of around 200. 64 might be a conservative default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The 3D mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>The mesh's edge topology (used for fast computation). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rendering_parameters</td><td>Rendering (pose) parameters of the mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_edges</td><td>A list of points that are edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_threshold</td><td>All correspondences below this threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair consisting of the used image edge points and their associated 3D vertex index. </dd></dl>

</div>
</div>
<a id="a95d28c44f5ac118eb15c1626e7aa0730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d28c44f5ac118eb15c1626e7aa0730">&#9670;&nbsp;</a></span>fit_blendshapes_to_landmarks_linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_blendshapes_to_landmarks_linear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>face_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>500.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits blendshape coefficients to given 2D landmarks, given a current face shape instance. It's a linear, closed-form solution fitting algorithm, with regularisation (constraining the L2-norm of the coefficients). However, there is no constraint on the coefficients, so negative coefficients are allowed, which, with linear blendshapes (offsets), will most likely not be desired. Thus, prefer the function fit_blendshapes_to_landmarks_nnls(std::vector&lt;eos::morphablemodel::Blendshape&gt;, cv::Mat, cv::Mat, std::vector&lt;cv::Vec2f&gt;, std::vector&lt;int&gt;).</p>
<p>This algorithm is very similar to the shape fitting in fit_shape_to_landmarks_linear. Instead of the PCA basis, the blendshapes are used, and instead of the mean, a current face instance is used to do the fitting from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector with blendshapes to estimate the coefficients for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_instance</td><td>A shape instance from which the blendshape coefficients should be estimated (i.e. the current mesh without expressions, e.g. estimated from a previous PCA-model fitting). A 3m x 1 matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix from model to screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the blendshapes to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>A regularisation parameter, constraining the L2-norm of the coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated blendshape-coefficients. </dd></dl>

</div>
</div>
<a id="a2a525814be9d4051deab4032344cdc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a525814be9d4051deab4032344cdc6e">&#9670;&nbsp;</a></span>fit_blendshapes_to_landmarks_nnls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_blendshapes_to_landmarks_nnls </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>face_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits blendshape coefficients to given 2D landmarks, given a current face shape instance. Uses non-negative least-squares (NNLS) to solve for the coefficients. The NNLS algorithm used doesn't support any regularisation.</p>
<p>This algorithm is very similar to the shape fitting in fit_shape_to_landmarks_linear. Instead of the PCA basis, the blendshapes are used, and instead of the mean, a current face instance is used to do the fitting from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector with blendshapes to estimate the coefficients for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_instance</td><td>A shape instance from which the blendshape coefficients should be estimated (i.e. the current mesh without expressions, e.g. estimated from a previous PCA-model fitting). A 3m x 1 matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix from model to screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the blendshapes to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated blendshape-coefficients. </dd></dl>

</div>
</div>
<a id="a8a38ffb693a9ab456d4e0d773aeb51a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a38ffb693a9ab456d4e0d773aeb51a5">&#9670;&nbsp;</a></span>fit_expressions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_expressions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeos_1_1morphablemodel.html#a13ad48bb1ba963a9a8f2c360be701a40">morphablemodel::ExpressionModel</a> &amp;&#160;</td>
          <td class="paramname"><em>expression_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXf &amp;&#160;</td>
          <td class="paramname"><em>face_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; float, 3, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lambda_expressions</em> = <code>cpp17::optional&lt;float&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_expression_coefficients_to_fit</em> = <code>cpp17::optional&lt;int&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fits the given expression model to landmarks. </p>
<p>The function uses fit_blendshapes_to_landmarks_nnls(...) if the given expression model consists of Blendshapes, and fit_shape_to_landmarks_linear(...) if it is a PCA model.</p>
<p>Note that if the expression model is a PCA model, and we're doing fit_shape_to_landmarks_linear(...), we should probably pass the regularisation and num_coeffs_to_fit along as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">expression_model</td><td>The expression model (blendshapes or a PCA model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_instance</td><td>A shape instance from which the expression coefficients should be estimated (i.e. the current mesh without expressions, e.g. estimated from a previous PCA-model fitting). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>Second vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the blendshapes to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_expressions</td><td>The regularisation parameter (weight of the prior towards the mean). Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_expression_coefficients_to_fit</td><td>How many expression coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. Only used for expression-PCA fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of fitted expression coefficients. </dd></dl>

</div>
</div>
<a id="ab06c5811029231027356c9674f1cf08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06c5811029231027356c9674f1cf08f">&#9670;&nbsp;</a></span>fit_shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf eos::fitting::fit_shape </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>pca_shape_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshape_coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that fits the shape model and expression blendshapes to landmarks. Makes the fitted PCA shape and blendshape coefficients accessible via the out parameters <code>pca_shape_coefficients</code> and <code>blendshape_coefficients</code>. It iterates PCA-shape and blendshape fitting until convergence (usually it converges within 5 to 10 iterations).</p>
<p>See fit_shape_model(cv::Mat, eos::morphablemodel::MorphableModel, std::vector&lt;eos::morphablemodel::Blendshape&gt;, std::vector&lt;cv::Vec2f&gt;, std::vector&lt;int&gt;, float lambda) for a simpler overload that just returns the shape instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>The estimated pose as a 3x4 affine camera matrix that is used to fit the shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector of blendshapes that are being fit to the landmarks in addition to the PCA model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_indices</td><td>The vertex indices in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pca_shape_coefficients</td><td>Output parameter that will contain the resulting pca shape coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">blendshape_coefficients</td><td>Output parameter that will contain the resulting blendshape coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance. </dd></dl>

</div>
</div>
<a id="aa6ab5ec634807ac639cd500e04fdbb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ab5ec634807ac639cd500e04fdbb70">&#9670;&nbsp;</a></span>fit_shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXf eos::fitting::fit_shape </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_coefficients_to_fit</em> = <code>cpp17::optional&lt;int&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function that fits the shape model and expression blendshapes to landmarks. It iterates PCA-shape and blendshape fitting until convergence (usually it converges within 5 to 10 iterations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>The estimated pose as a 3x4 affine camera matrix that is used to fit the shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector of blendshapes that are being fit to the landmarks in addition to the PCA model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_indices</td><td>The vertex indices in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance. </dd></dl>

</div>
</div>
<a id="aee3bf7d03ccc43f85b0311c9469e8c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3bf7d03ccc43f85b0311c9469e8c31">&#9670;&nbsp;</a></span>fit_shape_and_pose() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>&gt;, std::vector&lt;<a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a>&gt; &gt; eos::fitting::fit_shape_and_pose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;&#160;</td>
          <td class="paramname"><em>landmark_mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_shape_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_rendering_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>pca_shape_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshape_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Eigen::Vector2f &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_image_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. This function takes a set of images and landmarks and estimates per-frame pose and expressions, as well as identity shape jointly from all images. </p>
<p>Convenience function that fits pose (camera), the shape model, and expression blendshapes to landmarks, in an iterative (alternating) way. It fits both sides of the face contour as well.</p>
<p>If <code>pca_shape_coefficients</code> and/or <code>blendshape_coefficients</code> are given, they are used as starting values in the fitting. When the function returns, they contain the coefficients from the last iteration.</p>
<p>Use render::Mesh fit_shape_and_pose(const morphablemodel::MorphableModel&amp;, const std::vector&lt;morphablemodel::Blendshape&gt;&amp;, const core::LandmarkCollection&lt;Eigen::Vector2f&gt;&amp;, const core::LandmarkMapper&amp;, int, int, const morphablemodel::EdgeTopology&amp;, const fitting::ContourLandmarks&amp;, const fitting::ModelContour&amp;, int, cpp17::optional&lt;int&gt;, float). for a simpler overload with reasonable defaults and no optional output.</p>
<p><code>num_iterations:</code> Results are good for even a few iterations. For full convergence of all parameters, it can take up to 300 iterations. In tracking, particularly if initialising with the previous frame, it works well with as low as 1 to 5 iterations. <code>edge_topology</code> is used for the occluding-edge face contour fitting. <code>contour_landmarks</code> and <code>model_contour</code> are used to fit the front-facing contour.</p>
<p>Todo: Add a convergence criterion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector of blendshapes that are being fit to the landmarks in addition to the PCA model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_mapper</td><td>Mapping info from the 2D landmark points to 3D vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_width</td><td>Width of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_height</td><td>Height of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>Precomputed edge topology of the 3D model, needed for fast edge-lookup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations</td><td>Number of iterations that the different fitting parts will be alternated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_shape_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_rendering_params</td><td>Currently ignored (not used). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pca_shape_coefficients</td><td>If given, will be used as initial PCA shape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">blendshape_coefficients</td><td>If given, will be used as initial expression blendshape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fitted_image_points</td><td>Debug parameter: Returns all the 2D points that have been used for the fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance and the final pose. </dd></dl>

</div>
</div>
<a id="a44553df236553dcceeae64d9128c6d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44553df236553dcceeae64d9128c6d69">&#9670;&nbsp;</a></span>fit_shape_and_pose() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a>&gt; eos::fitting::fit_shape_and_pose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;&#160;</td>
          <td class="paramname"><em>landmark_mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_shape_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda_identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_expression_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lambda_expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_rendering_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>pca_shape_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_image_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. </p>
<p>Convenience function that fits pose (camera), the shape model, and expression blendshapes to landmarks, in an iterative (alternating) way. It fits both sides of the face contour as well.</p>
<p>If <code>pca_shape_coefficients</code> and/or <code>blendshape_coefficients</code> are given, they are used as starting values in the fitting. When the function returns, they contain the coefficients from the last iteration.</p>
<p>Use render::Mesh fit_shape_and_pose(const morphablemodel::MorphableModel&amp;, const std::vector&lt;morphablemodel::Blendshape&gt;&amp;, const core::LandmarkCollection&lt;cv::Vec2f&gt;&amp;, const core::LandmarkMapper&amp;, int, int, const morphablemodel::EdgeTopology&amp;, const fitting::ContourLandmarks&amp;, const fitting::ModelContour&amp;, int, cpp17::optional&lt;int&gt;, float). for a simpler overload with reasonable defaults and no optional output.</p>
<p><code>num_iterations:</code> Results are good for even a single iteration. For single-image fitting and for full convergence of all parameters, it can take up to 300 iterations. In tracking, particularly if initialising with the previous frame, it works well with as low as 1 to 5 iterations. <code>edge_topology</code> is used for the occluding-edge face contour fitting. <code>contour_landmarks</code> and <code>model_contour</code> are used to fit the front-facing contour.</p>
<p>Note: If the given <code>morphable_model</code> contains a PCA expression model, alternating the shape identity and expression fitting is theoretically not needed - the basis matrices could be stacked, and then both coefficients could be solved for in one go. The two bases are most likely not orthogonal though. In any case, alternating hopefully doesn't do any harm.</p>
<p>Todo: Add a convergence criterion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_mapper</td><td>Mapping info from the 2D landmark points to 3D vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_width</td><td>Width of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_height</td><td>Height of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>Precomputed edge topology of the 3D model, needed for fast edge-lookup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations</td><td>Number of iterations that the different fitting parts will be alternated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_shape_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_identity</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_expression_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_expressions</td><td>Regularisation parameter of the expression fitting. Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_rendering_params</td><td>Currently ignored (not used). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pca_shape_coefficients</td><td>If given, will be used as initial PCA shape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expression_coefficients</td><td>If given, will be used as initial expression blendshape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fitted_image_points</td><td>Debug parameter: Returns all the 2D points that have been used for the fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance and the final pose. </dd></dl>

</div>
</div>
<a id="ae06cbad9ff38bdbb898f9df170b616a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06cbad9ff38bdbb898f9df170b616a2">&#9670;&nbsp;</a></span>fit_shape_and_pose() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::vector&lt;<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>&gt;, std::vector&lt;<a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a>&gt; &gt; eos::fitting::fit_shape_and_pose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;&#160;</td>
          <td class="paramname"><em>landmark_mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_shape_coefficients_to_fit</em> = <code>cpp17::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>30.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. This function takes a set of images and landmarks and estimates per-frame pose and expressions, as well as identity shape jointly from all images. </p>
<p>Convenience function that fits pose (camera), the shape model, and expression blendshapes to landmarks, in an iterative (alternating) way. It fits both sides of the face contour as well.</p>
<p>If <code>pca_shape_coefficients</code> and/or <code>blendshape_coefficients</code> are given, they are used as starting values in the fitting. When the function returns, they contain the coefficients from the last iteration.</p>
<p>If you want to access the values of shape or blendshape coefficients, or want to set starting values for them, use the following overload to this function: std::pair&lt;render::Mesh, fitting::RenderingParameters&gt; fit_shape_and_pose(const morphablemodel::MorphableModel&amp;, const std::vector&lt;morphablemodel::Blendshape&gt;&amp;, const core::LandmarkCollection&lt;Eigen::Vector2f&gt;&amp;, const core::LandmarkMapper&amp;, int, int, const morphablemodel::EdgeTopology&amp;, const fitting::ContourLandmarks&amp;, const fitting::ModelContour&amp;, int, cpp17::optional&lt;int&gt;, float, cpp17::optional&lt;fitting::RenderingParameters&gt;, std::vector&lt;float&gt;&amp;, std::vector&lt;float&gt;&amp;, std::vector&lt;Eigen::Vector2f&gt;&amp;)</p>
<p><code>num_iterations:</code> Results are good for even a few iterations. For full convergence of all parameters, it can take up to 300 iterations. In tracking, particularly if initialising with the previous frame, it works well with as low as 1 to 5 iterations. <code>edge_topology</code> is used for the occluding-edge face contour fitting. <code>contour_landmarks</code> and <code>model_contour</code> are used to fit the front-facing contour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A vector of blendshapes that are being fit to the landmarks in addition to the PCA model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_mapper</td><td>Mapping info from the 2D landmark points to 3D vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_width</td><td>Width of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_height</td><td>Height of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>Precomputed edge topology of the 3D model, needed for fast edge-lookup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations</td><td>Number of iterations that the different fitting parts will be alternated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_shape_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance and the final pose. </dd></dl>

</div>
</div>
<a id="ab9dd151a721a9c15e98fd8ad0e8de65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9dd151a721a9c15e98fd8ad0e8de65a">&#9670;&nbsp;</a></span>fit_shape_and_pose() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a>&gt; eos::fitting::fit_shape_and_pose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;&#160;</td>
          <td class="paramname"><em>landmark_mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">fitting::ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">fitting::ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_shape_coefficients_to_fit</em> = <code>cpp17::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda_identity</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_expression_coefficients_to_fit</em> = <code>cpp17::nullopt</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lambda_expressions</em> = <code>cpp17::nullopt</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. </p>
<p>Convenience function that fits pose (camera), the shape model, and expression blendshapes to landmarks, in an iterative (alternating) way. It fits both sides of the face contour as well.</p>
<p>If you want to access the values of shape or blendshape coefficients, or want to set starting values for them, use the following overload to this function: std::pair&lt;render::Mesh, fitting::RenderingParameters&gt; fit_shape_and_pose(const morphablemodel::MorphableModel&amp;, const std::vector&lt;morphablemodel::Blendshape&gt;&amp;, const core::LandmarkCollection&lt;cv::Vec2f&gt;&amp;, const core::LandmarkMapper&amp;, int, int, const morphablemodel::EdgeTopology&amp;, const fitting::ContourLandmarks&amp;, const fitting::ModelContour&amp;, int, cpp17::optional&lt;int&gt;, float, cpp17::optional&lt;fitting::RenderingParameters&gt;, std::vector&lt;float&gt;&amp;, std::vector&lt;float&gt;&amp;, std::vector&lt;cv::Vec2f&gt;&amp;)</p>
<p>Todo: Add a convergence criterion.</p>
<p><code>num_iterations:</code> Results are good for even a single iteration. For single-image fitting and for full convergence of all parameters, it can take up to 300 iterations. In tracking, particularly if initialising with the previous frame, it works well with as low as 1 to 5 iterations. <code>edge_topology</code> is used for the occluding-edge face contour fitting. <code>contour_landmarks</code> and <code>model_contour</code> are used to fit the front-facing contour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_mapper</td><td>Mapping info from the 2D landmark points to 3D vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_width</td><td>Width of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_height</td><td>Height of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>Precomputed edge topology of the 3D model, needed for fast edge-lookup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations</td><td>Number of iterations that the different fitting parts will be alternated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_shape_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_identity</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_expression_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_expressions</td><td>Regularisation parameter of the expression fitting. Only used for expression-PCA fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance and the final pose. </dd></dl>

</div>
</div>
<a id="a74d6849dadaa06ace1d69d5600f85cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d6849dadaa06ace1d69d5600f85cb2">&#9670;&nbsp;</a></span>fit_shape_and_pose() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a>, <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a>&gt; eos::fitting::fit_shape_and_pose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>image_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_shape_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda_identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_expression_coefficients_to_fit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lambda_expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">fitting::RenderingParameters</a> &gt;&#160;</td>
          <td class="paramname"><em>initial_rendering_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>pca_shape_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>expression_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>fitted_image_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fit the pose (camera), shape model, and expression blendshapes to landmarks, in an iterative way. </p>
<p>Convenience function that fits pose (camera), the shape model, and expression blendshapes to landmarks, in an iterative (alternating) way. It uses the given, fixed landmarks-to-vertex correspondences, and does not use any dynamic contour fitting.</p>
<p>If <code>pca_shape_coefficients</code> and/or <code>blendshape_coefficients</code> are given, they are used as starting values in the fitting. When the function returns, they contain the coefficients from the last iteration.</p>
<p><code>num_iterations:</code> Results are good for even a single iteration. For single-image fitting and for full convergence of all parameters, it can take up to 300 iterations. In tracking, particularly if initialising with the previous frame, it works well with as low as 1 to 5 iterations. <code>edge_topology</code> is used for the occluding-edge face contour fitting. <code>contour_landmarks</code> and <code>model_contour</code> are used to fit the front-facing contour.</p>
<p>Note: If the given <code>morphable_model</code> contains a PCA expression model, alternating the shape identity and expression fitting is theoretically not needed - the basis matrices could be stacked, and then both coefficients could be solved for in one go. The two bases are most likely not orthogonal though. In any case, alternating hopefully doesn't do any harm.</p>
<p>Todo: Add a convergence criterion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The 3D Morphable Model used for the shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>2D image points to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_indices</td><td>The 3D vertex indices corresponding to the given image_points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_width</td><td>Width of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">image_height</td><td>Height of the input image (needed for the camera model). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_iterations</td><td>Number of iterations that the different fitting parts will be alternated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_shape_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_identity</td><td>Regularisation parameter of the PCA shape fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_expression_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda_expressions</td><td>Regularisation parameter of the expression fitting. Only used for expression-PCA fitting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initial_rendering_params</td><td>Currently ignored (not used). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pca_shape_coefficients</td><td>If given, will be used as initial PCA shape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">expression_coefficients</td><td>If given, will be used as initial expression blendshape coefficients to start the fitting. Will contain the final estimated coefficients. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fitted_image_points</td><td>Debug parameter: Returns all the 2D points that have been used for the fitting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fitted model shape instance and the final pose. </dd></dl>

</div>
</div>
<a id="a9f844c8d820313b3cfe8ab0b7e740c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f844c8d820313b3cfe8ab0b7e740c0a">&#9670;&nbsp;</a></span>fit_shape_to_landmarks_linear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_shape_to_landmarks_linear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;&#160;</td>
          <td class="paramname"><em>shape_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; float, 3, 4 &gt;&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXf&#160;</td>
          <td class="paramname"><em>base_face</em> = <code>Eigen::VectorXf()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_coefficients_to_fit</em> = <code>cpp17::optional&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>detector_standard_deviation</em> = <code>cpp17::optional&lt;float&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>model_standard_deviation</em> = <code>cpp17::optional&lt;float&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits the shape of a Morphable Model to given 2D landmarks (i.e. estimates the maximum likelihood solution of the shape coefficients) as proposed in [1]. It's a linear, closed-form solution fitting of the shape, with regularisation (prior towards the mean).</p>
<p>[1] O. Aldrian &amp; W. Smith, Inverse Rendering of Faces with a 3D Morphable Model, PAMI 2013.</p>
<p>Note: Using less than the maximum number of coefficients to fit is not thoroughly tested yet and may contain an error. Note: Returns coefficients following standard normal distribution (i.e. all have similar magnitude). Why? Because we fit using the normalised basis? Note: The standard deviations given should be a vector, i.e. different for each landmark. This is not implemented yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape_model</td><td>The Morphable Model whose shape (coefficients) are estimated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix from model to screen-space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_face</td><td>The base or reference face from where the fitting is started. Usually this would be the models mean face, which is what will be used if the parameter is not explicitly specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The regularisation parameter (weight of the prior towards the mean). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coefficients_to_fit</td><td>How many shape coefficients to fit (all others will stay 0). Should be bigger than zero, or std::nullopt to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detector_standard_deviation</td><td>The standard deviation of the 2D landmarks given (e.g. of the detector used), in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_standard_deviation</td><td>The standard deviation of the 3D vertex points in the 3D model, projected to 2D (so the value is in pixels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated shape coefficients (alphas). </dd></dl>

</div>
</div>
<a id="a193b0cb88e23a6870304f0b68ed230cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193b0cb88e23a6870304f0b68ed230cd">&#9670;&nbsp;</a></span>fit_shape_to_landmarks_linear_multi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_shape_to_landmarks_linear_multi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;&#160;</td>
          <td class="paramname"><em>shape_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Matrix&lt; float, 3, 4 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>affine_camera_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Eigen::Vector2f &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::VectorXf &gt;&#160;</td>
          <td class="paramname"><em>base_faces</em> = <code>std::vector&lt;Eigen::VectorXf&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_coefficients_to_fit</em> = <code>cpp17::optional&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>detector_standard_deviation</em> = <code>cpp17::optional&lt;float&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cpp17::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>model_standard_deviation</em> = <code>cpp17::optional&lt;float&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits the shape of a Morphable Model to given 2D landmarks from multiple images.</p>
<p>See the documentation of the single-image version, fit_shape_to_landmarks_linear(...).</p>
<p>Note: I think fit_shape_to_landmarks_linear(...) got updated since Philipp wrote this, so maybe we could copy some of these updates from above.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape_model</td><td>The Morphable Model whose shape (coefficients) are estimated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrices</td><td>A 3x4 affine camera matrix from model to screen-space (should probably be of type CV_32FC1 as all our calculations are done with float). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image to fit the model to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base_faces</td><td>The base or reference face from where the fitting is started. Usually this would be the models mean face, which is what will be used if the parameter is not explicitly specified. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The regularisation parameter (weight of the prior towards the mean). Gets normalized by the number of images given. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Should be bigger than zero, or boost::none to fit all coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detector_standard_deviation</td><td>The standard deviation of the 2D landmarks given (e.g. of the detector used), in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_standard_deviation</td><td>The standard deviation of the 3D vertex points in the 3D model, projected to 2D (so the value is in pixels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated shape-coefficients (alphas). </dd></dl>

</div>
</div>
<a id="ae171e545d0896a74976e2d9a62369370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae171e545d0896a74976e2d9a62369370">&#9670;&nbsp;</a></span>get_3x4_affine_camera_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;float, 3, 4&gt; eos::fitting::get_3x4_affine_camera_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a 3x4 affine camera matrix from given fitting parameters. The matrix transforms points directly from model-space to screen-space. </p>
<p>This function is mainly used since the linear shape fitting <a class="el" href="namespaceeos_1_1fitting.html#a9f844c8d820313b3cfe8ab0b7e740c0a">fitting::fit_shape_to_landmarks_linear</a> expects one of these 3x4 affine camera matrices, as well as <a class="el" href="namespaceeos_1_1render.html#adfe6cc3a347b8a0df2cac0f5c21c1f72">render::extract_texture</a>. </p>

</div>
</div>
<a id="a140ead165ca9fc56180ad938cfc37efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140ead165ca9fc56180ad938cfc37efd">&#9670;&nbsp;</a></span>get_contour_correspondences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;std::vector&lt;Eigen::Vector2f&gt;, std::vector&lt;Eigen::Vector4f&gt;, std::vector&lt;int&gt; &gt; eos::fitting::get_contour_correspondences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yaw_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>view_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>ortho_projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of 2D image landmarks, finds the closest (in a L2 sense) 3D vertex from a list of vertices pre-defined in <code>model_contour</code>. <code>landmarks</code> can contain all landmarks, and the function will sub-select the relevant contour landmarks with the help of the given <code>contour_landmarks</code>. This function choses the front-facing contour and only fits this contour to the 3D model, since these correspondences are approximately static and do not move with changing pose-angle.</p>
<p>It's the main contour fitting function that calls all other functions.</p>
<p>Note: Maybe rename to find_contour_correspondences, to highlight that there is (potentially a lot) computational cost involved? Note: Does ortho_projection have to be specifically orthographic? Otherwise, if it works with perspective too, rename to just "projection".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>All image landmarks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw_angle</td><td>Yaw angle of the current fitting, in degrees. The front-facing contour will be chosen depending on this yaw angle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh that's used to find the nearest contour points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view_model</td><td>Model-view matrix of the current fitting to project the 3D model vertices to 2D. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ortho_projection</td><td>Projection matrix to project the 3D model vertices to 2D. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Current viewport to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the 2D contour landmark points, the corresponding points in the 3D shape model and their vertex indices. </dd></dl>

</div>
</div>
<a id="a73cb82b9f04cb095e9e763672b358018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cb82b9f04cb095e9e763672b358018">&#9670;&nbsp;</a></span>get_corresponding_pointset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto eos::fitting::get_corresponding_pointset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1core_1_1_landmark_mapper.html">core::LandmarkMapper</a> &amp;&#160;</td>
          <td class="paramname"><em>landmark_mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> &amp;&#160;</td>
          <td class="paramname"><em>morphable_model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a LandmarkCollection of 2D landmarks and, using the landmark_mapper, finds the corresponding 3D vertex indices and returns them, along with the coordinates of the 3D points. </p>
<p>The function only returns points which the landmark mapper was able to convert, and skips all points for which there is no mapping. Thus, the number of returned points might be smaller than the number of input points. All three output vectors have the same size and contain the points in the same order. <code>landmarks</code> can be an <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe" title="A trivial collection of landmarks that belong together. ">eos::core::LandmarkCollection&lt;cv::Vec2f&gt;</a> or an rcr::LandmarkCollection&lt;cv::Vec2f&gt;.</p>
<p>Notes:</p><ul>
<li>Split into two functions, one which maps from 2D LMs to vtx_idx and returns a reduced vec of 2D LMs. And then the other one to go from vtx_idx to a vector&lt;Vec4f&gt;.</li>
<li>Place in a potentially more appropriate header (shape-fitting?).</li>
<li>Could move to detail namespace or forward-declare.</li>
<li><code>landmarks</code> has to be a collection of LMs, with size(), [] and Vec2f ::coordinates.</li>
<li>Probably model_points would better be a Vector3f and not in homogeneous coordinates?</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>A LandmarkCollection of 2D landmarks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_mapper</td><td>A mapper which maps the 2D landmark identifiers to 3D model vertex indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>Model to get the 3D point coordinates from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of [image_points, model_points, vertex_indices]. </dd></dl>

</div>
</div>
<a id="a39b82996959bc351f7fb2afd72a701b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b82996959bc351f7fb2afd72a701b9">&#9670;&nbsp;</a></span>get_nearest_contour_correspondences()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; Eigen::Vector2f &gt;, std::vector&lt; Eigen::Vector4f &gt;, std::vector&lt; int &gt; &gt; eos::fitting::get_nearest_contour_correspondences </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceeos_1_1core.html#a2e387e1c6514d710eece73f9edd727fe">core::LandmarkCollection</a>&lt; Eigen::Vector2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>landmark_contour_identifiers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>model_contour_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>view_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>ortho_projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of 2D image landmarks, finds the closest (in a L2 sense) 3D vertex from a list of vertices pre-defined in <code>model_contour</code>. Assumes to be given contour correspondences of the front-facing contour.</p>
<p>Todo: Return Vector3f here instead of Vector4f?</p>
<p>Note: Maybe rename to find_nearest_contour_points, to highlight that there is (potentially a lot) computational cost involved? Note: Does ortho_projection have to be specifically orthographic? Otherwise, if it works with perspective too, rename to just "projection". Note: Actually, only return the vertex id, not the model point as well? Same with get_corresponding_pointset?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>All image landmarks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmark_contour_identifiers</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour_indices</td><td>The model contour indices that should be considered to find the closest corresponding 3D vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh that's projected to find the nearest contour vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">view_model</td><td>Model-view matrix of the current fitting to project the 3D model vertices to 2D. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ortho_projection</td><td>Projection matrix to project the 3D model vertices to 2D. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>Current viewport to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple with the 2D contour landmark points, the corresponding points in the 3D shape model and their vertex indices. </dd></dl>

</div>
</div>
<a id="a8cbd14805664180f3eca321aa8be8c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbd14805664180f3eca321aa8be8c0d">&#9670;&nbsp;</a></span>get_shape_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; eos::fitting::get_shape_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;&#160;</td>
          <td class="paramname"><em>shape_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structeos_1_1morphablemodel_1_1_blendshape.html">morphablemodel::Blendshape</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blendshapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>shape_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>blendshape_coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 3D position of a single point of the 3D shape generated by the parameters given.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape_model</td><td>A PCA 3D shape model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshapes</td><td>A set of 3D blendshapes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_id</td><td>Vertex id of the 3D model that should be projected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape_coeffs</td><td>A set of PCA shape coefficients used to generate the point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blendshape_coeffs</td><td>A set of blendshape coefficients used to generate the point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 3D point. </dd></dl>

</div>
</div>
<a id="a80cd220776a04f2738b80930c1cc70a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cd220776a04f2738b80930c1cc70a7">&#9670;&nbsp;</a></span>get_vertex_colour()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; eos::fitting::get_vertex_colour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classeos_1_1morphablemodel_1_1_pca_model.html">morphablemodel::PcaModel</a> &amp;&#160;</td>
          <td class="paramname"><em>color_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>color_coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the colour value of a single point of the 3D model generated by the parameters given.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">color_model</td><td>A PCA 3D colour (albedo) model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_id</td><td>Vertex id of the 3D model whose colour is to be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color_coeffs</td><td>A set of PCA colour coefficients. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The colour. As RGB? In [0, 1]? </dd></dl>

</div>
</div>
<a id="aa51ab38e4c0c16cd94655c7010f97390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ab38e4c0c16cd94655c7010f97390">&#9670;&nbsp;</a></span>occluding_boundary_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; eos::fitting::occluding_boundary_vertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structeos_1_1core_1_1_mesh.html">core::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1morphablemodel_1_1_edge_topology.html">morphablemodel::EdgeTopology</a> &amp;&#160;</td>
          <td class="paramname"><em>edge_topology</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::mat4x4&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the vertices that lie on occluding boundaries, given a particular pose. </p>
<p>This algorithm computes the edges that lie on occluding boundaries of the mesh. It performs a visibility text of each vertex, and returns a list of the (unique) vertices that make the boundary edges. An edge is defined as the line whose two adjacent faces normals flip the sign.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edge_topology</td><td>The edge topology of the given mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>The rotation (pose) under which the occluding boundaries should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with unique vertex id's making up the edges. </dd></dl>

</div>
</div>
<a id="a3e99a34e412f0bb5b2c6568dd37ae413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e99a34e412f0bb5b2c6568dd37ae413">&#9670;&nbsp;</a></span>project_affine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Vec2f eos::fitting::project_affine </td>
          <td>(</td>
          <td class="paramtype">cv::Vec4f&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projects a point from world coordinates to screen coordinates. First, an estimated affine camera matrix is used to transform the point to clip space. Second, the point is transformed to screen coordinates using the window transform. The window transform also flips the y-axis (the image origin is top-left, while in clip space top is +1 and bottom is -1).</p>
<p>Note: Assumes the affine camera matrix only projects from world to clip space, because a subsequent window transform is applied. Todo: This is outdated, now that we estimate the matrix from world to screen space directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>A vertex in 3D space. vertex[3] = 1.0f. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window used for projection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window used for projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to screen coordinates. </dd></dl>

</div>
</div>
<a id="a6224885ee6804c12195f04a4b7206f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6224885ee6804c12195f04a4b7206f2f">&#9670;&nbsp;</a></span>ray_triangle_intersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, cpp17::optional&lt;float&gt; &gt; eos::fitting::ray_triangle_intersect </td>
          <td>(</td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>ray_origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>ray_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_backculling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of the given ray with the given triangle. </p>
<p>Uses the Mller-Trumbore algorithm algorithm "Fast Minimum Storage
Ray/Triangle Intersection". Independent implementation, inspired by: <a href="http://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection">http://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection</a> The default eps (1e-6f) is from the paper. When culling is on, rays intersecting triangles from the back will be discarded - otherwise, the triangles normal direction w.r.t. the ray direction is just ignored.</p>
<p>Note: The use of optional might turn out as a performance problem, as this function is called loads of time - how costly is it to construct an std::nullopt?</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_origin</td><td>Ray origin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray_direction</td><td>Ray direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>First vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Second vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Third vertex of a triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable_backculling</td><td>When culling is on, rays intersecting triangles from the back will be discarded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the ray intersects the triangle, and if yes, including the distance. </dd></dl>

</div>
</div>
<a id="a03b4bc35b0619e7f4bd0fccbb2d35e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b4bc35b0619e7f4bd0fccbb2d35e2c">&#9670;&nbsp;</a></span>save_rendering_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::fitting::save_rendering_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html">RenderingParameters</a>&#160;</td>
          <td class="paramname"><em>rendering_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves the rendering parameters for an image to a json file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rendering_parameters</td><td>An instance of class <a class="el" href="classeos_1_1fitting_1_1_rendering_parameters.html" title="Represents a set of estimated model parameters (rotation, translation) and camera parameters (viewing...">RenderingParameters</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The file to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if unable to open the given file for writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a307eaa4a1a9f2c5e2c33a95a6e261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a307eaa4a1a9f2c5e2c33a95a6e261d">&#9670;&nbsp;</a></span>select_contour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::vector&lt; int &gt; &gt; eos::fitting::select_contour </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yaw_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_contour_landmarks.html">ContourLandmarks</a> &amp;&#160;</td>
          <td class="paramname"><em>contour_landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structeos_1_1fitting_1_1_model_contour.html">ModelContour</a> &amp;&#160;</td>
          <td class="paramname"><em>model_contour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes a set of 2D and 3D contour landmarks and a yaw angle and returns two vectors with either the right or the left 2D and 3D contour indices. This function does not establish correspondence between the 2D and 3D landmarks, it just selects the front-facing contour. The two returned vectors can thus have different size. Correspondence can be established using <a class="el" href="namespaceeos_1_1fitting.html#a39b82996959bc351f7fb2afd72a701b9">get_nearest_contour_correspondences()</a>.</p>
<p>If the yaw angle is between +-7.5, both contours will be selected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yaw_angle</td><td>Yaw angle in degrees. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contour_landmarks</td><td>2D image contour ids of left or right side (for example for ibug landmarks). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_contour</td><td>The model contour indices that should be used/considered to find the closest corresponding 3D vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair with two vectors containing the selected 2D image contour landmark ids and the 3D model contour indices. </dd></dl>

</div>
</div>
<a id="a1c824c19fe9ef8a208d0d73360b71159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c824c19fe9ef8a208d0d73360b71159">&#9670;&nbsp;</a></span>to_eigen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;float, 4, 4&gt; eos::fitting::to_eigen </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>glm_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a glm::mat4x4 to an Eigen::Matrix&lt;float, 4, 4&gt;. </p>
<p>Note: I think the last use of this function is below in <a class="el" href="namespaceeos_1_1fitting.html#ae171e545d0896a74976e2d9a62369370" title="Creates a 3x4 affine camera matrix from given fitting parameters. The matrix transforms points direct...">get_3x4_affine_camera_matrix()</a>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
